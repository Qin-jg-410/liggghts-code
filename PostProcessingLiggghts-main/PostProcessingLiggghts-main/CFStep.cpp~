#include "Headers/Step.h"

// ========================================================
// Fonctions de la classe Step, type CFStep================
// ========================================================
// ========================================================
// Fonctions orientées LCFStep ============================
//=========================================================
void Step::LCFdisp(void)
{
  cout << "Timestep : " << timestep << "\n" ;
  cout << "Nb entrées : " << nb_atomes << "\n" ;
  cout << "Nb idx : " << nb_idx << "\n\n" ;
}
//-------------------------------------------------------------
int Step::grain_force(double ** meanforces, int * meangrains)
{
double dtheta, angle, anglecentre, Fn ; int boites ;
int i, j, idx[9], fen ;
double **forces, factor, sigma ; int *grains ;
static bool info=true ;

// Initialisation des boites
boites=actions["grainforce-by-angle"]["nbbox_theta"] ;
dtheta=2*M_PI/(double)boites ;
// Initialisation des tableaux
forces=(double **)malloc(boites*sizeof(double *)) ;
grains=(int *)malloc(boites*sizeof(int)) ;
for (i=0 ; i<boites ; i++)
   {forces[i]=(double *)malloc(3*sizeof(double)) ; forces[i][0]=forces[i][1]=forces[i][2]=0 ;}

// Initialisation des index
idx[0]=find_idx(CFFORCEX) ; idx[1]=find_idx(CFFORCEY) ; idx[2]=find_idx(CFFORCEZ) ;
idx[3]=find_idx(CFX) ; idx[4]=find_idx(CFY) ; idx[5]=find_idx(CFZ) ;
idx[6]=find_idx(CFID1) ; idx[7]=find_idx(CFID2) ; idx[8]=find_idx(CFPERIOD) ;
if (idx[0]==-1||idx[1]==-1||idx[2]==-1||idx[3]==-1||idx[4]==-1||idx[5]==-1)
   {DISP_Err("Les valeurs CFFORCEX/Y/Z et CFX/Y/Z sont necessaires avec --grainforce_by_angle et un CFdump") ; return 0 ; }

if (has_periodic_chains==true) return 0 ;

if (actions["grainforce-by-angle"]["sigma"]==0) {fen=1; if (info) {DISP_Info("Utilisation d'une fenêtre créneau") ; info=false ; } } // Fenêtre créneau
else {sigma=actions["grainforce-by-angle"]["sigma"]/180*M_PI ; fen=2; if(info) {DISP_Info ("Utilisation d'une fenêtre gaussienne") ; info=false ; } } // Fenêtre gaussienne

// Parcours des atomes, ajout des forces aux angles adaptés
int sgn ;
for (i=0 ; i<nb_atomes ; i++)
	{
	if (datas[idx[8]][i]==1) return 0 ;
    if (datas[idx[7]][i]==actions["grainforce-by-angle"]["id"]) sgn=-1;
	else if (datas[idx[6]][i]==actions["grainforce-by-angle"]["id"]) sgn=1 ;  //Tout va bien
	else {DISP_Warn("Il n'y a pas le bon ID dans la chaines !") ; continue ; }

	angle=Calcul::arctan(datas[idx[3]][i]*sgn, datas[idx[4]][i]*sgn) ;
	angle=Calcul::angle_0_2pi(angle) ;

	for (j=0 ; j<boites ; j++)
	   {
	   anglecentre=angle-(j*dtheta+dtheta/2) ;
	   if (anglecentre>M_PI) anglecentre=anglecentre-2*M_PI ;
	   if (anglecentre<-M_PI) anglecentre=anglecentre+2*M_PI ;
	   if (fen==1) Fonction::creneau1D (factor, anglecentre, dtheta) ;
	   else     Fonction::gaussienne1D (factor, anglecentre, sigma ) ;

	   factor*=dtheta ;
	   // Force totale
	   forces[j][0]+=(factor*datas[idx[0]][i]*sgn) ; forces[j][1]+=(factor*datas[idx[1]][i]*sgn) ; forces[j][2]+=(factor*datas[idx[2]][i]*sgn) ;

	   // Force normale
	   /*Fn=datas[idx[0]][i]*cos(angle)+datas[idx[2]][i]*sin(angle) ;
	   forces[j][3]+=factor*Fn ;

	   // Force tangentielle
	   forces[j][4]+=factor*(datas[idx[0]][i]-Fn*cos(angle)) ;
	   forces[j][5]+=factor*(datas[idx[1]][i]) ;
	   forces[j][6]+=factor*(datas[idx[2]][i]-Fn*sin(angle)) ;
       */
	   grains[j]+=factor ;
	   }

	 }

// Ecriture des données et éventuellement ajout pour moyennage
for (i=0 ; i<boites ; i++)
   {
   if (actions["mean"].set)
      { for (j=0 ; j<3 ; j++) meanforces[i][j]+=forces[i][j] ;
        meangrains[i]+=grains[i] ; }
   //out << (i*dtheta+dtheta/2) << " " << grains[i] << " "<< forces[i][0] << " " << forces[i][1] << " " << forces[i][2] << " " << forces[i][3] << " ";
   //out << forces[i][4] << " " << forces[i][5] << " " << forces[i][6] << " " ;
   }

// Cleanning
for (i=0 ; i<boites ; i++)
   {free(forces[i]) ; }
free(forces) ;
free(grains) ;

return 1 ;
}
//-----------------------------
int Step::LCFwrite_asVTK(ofstream & out, Step & step)
{
// C'est là qu'on rigole ...
int i , idxcf[12], idx[4];
int nb_liens ;

idxcf[0]=find_idx(CFID1) ;
idxcf[1]=find_idx(CFID2) ;
idxcf[2]=find_idx(CFFORCEX) ;
idxcf[3]=find_idx(CFFORCEY) ;
idxcf[4]=find_idx(CFFORCEZ) ;
idxcf[5]=find_idx(CFMAG) ;
idxcf[6]=find_idx(CFX) ;
idxcf[7]=find_idx(CFY) ;
idxcf[8]=find_idx(CFZ) ;
idxcf[9]=find_idx(POSX) ;
idxcf[10]=find_idx(POSY) ;
idxcf[11]=find_idx(POSZ) ;
// On vérifie que les id augmentent linéairement par pas de 1 (pour simplifier ...) dans le LucDump
/*idx[0]=step.find_idx(ID) ;
for (i=0 ; i<step.nb_atomes ; i++)
    {
    if (step.datas[idx[0]][i]!=i+1) {cout << "ERR : les ID n'augmentent pas par pas de 1 dans le LucDump. Programme à revoir ..." ; return -1 ; }
    }*/

// Si cutoff

if (actions["cutoff"].set)
   {
   nb_liens=floor((double)(actions["cutoff"]["cutoff"]/100.*nb_atomes)) ;
   }
else
   {
   nb_liens=nb_atomes ;
   }

// Header
out << "# vtk DataFile Version 2.0\n" ;
out << "Generated by AVFF. Chainforces !\nASCII\nDATASET POLYDATA\n" ;
out << "POINTS " << nb_liens*2 << " double\n" ;

idx[1]=step.find_idx(POSX) ;
idx[2]=step.find_idx(POSY) ;
idx[3]=step.find_idx(POSZ) ;

/*for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
{
 //if (actions.between)
 //   {
 //   if (step.datas[idx[3]][datas[idxcf[0]][i]-1] > actions.params["betweenlo"] && step.datas[idx[3]][datas[idxcf[1]][i]-1] > actions.params["betweenlo"]
 //      && step.datas[idx[3]][datas[idxcf[0]][i]-1] < actions.params["betweenhi"] && step.datas[idx[3]][datas[idxcf[1]][i]-1] < actions.params["betweenho"])
 //      {
 //      out << step.datas[idx[1]][datas[idxcf[0]][i]-1] << " " << step.datas[idx[2]][datas[idxcf[0]][i]-1] << " " << step.datas[idx[3]][datas[idxcf[0]][i]-1] << "\n" ;
 //      out << step.datas[idx[1]][datas[idxcf[1]][i]-1] << " " << step.datas[idx[2]][datas[idxcf[1]][i]-1] << " " << step.datas[idx[3]][datas[idxcf[1]][i]-1] << "\n" ;
 //      }
 //   }
 //else
 //   {
 //   }
out << step.datas[idx[1]][(int)datas[idxcf[0]][i]-1] << " " << step.datas[idx[2]][(int)datas[idxcf[0]][i]-1] << " " << step.datas[idx[3]][(int)datas[idxcf[0]][i]-1] << "\n" ;
out << step.datas[idx[1]][(int)datas[idxcf[1]][i]-1] << " " << step.datas[idx[2]][(int)datas[idxcf[1]][i]-1] << " " << step.datas[idx[3]][(int)datas[idxcf[1]][i]-1] << "\n" ;

}*/

for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
	{
	out << datas[idxcf[9]][i]-datas[idxcf[6]][i]/2 << " " << datas[idxcf[10]][i]-datas[idxcf[7]][i]/2 << " " << datas[idxcf[11]][i]-datas[idxcf[8]][i]/2 << "\n" ;
	out << datas[idxcf[9]][i]+datas[idxcf[6]][i]/2 << " " << datas[idxcf[10]][i]+datas[idxcf[7]][i]/2 << " " << datas[idxcf[11]][i]+datas[idxcf[8]][i]/2 << "\n" ;
	}

out << "LINES " << nb_liens << " "<< nb_liens*3 << "\n" ;

for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
  {out << "2 " << (i-nb_atomes+nb_liens)*2 << " " << (i-nb_atomes+nb_liens)*2+1 <<"\n" ; out.flush() ;}

out << "POINT_DATA " << nb_liens*2 << "\n" ;
out << "SCALARS magnitude double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {out << datas[idxcf[5]][i] << " " << datas[idxcf[5]][i] << " " ;}

out << "SCALARS deltan double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
double deltan ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {deltan=sqrt(datas[idxcf[6]][i]*datas[idxcf[6]][i]+datas[idxcf[7]][i]*datas[idxcf[7]][i]+datas[idxcf[8]][i]*datas[idxcf[8]][i]) ;
	out << 0.0015-deltan << " " << 0.0015-deltan << " " ;}


out << "\nVECTORS force double\n" ;
for (i=0 ; i<nb_atomes ; i++)
  {
  out <<datas[idxcf[2]][i] << " " << datas[idxcf[3]][i] << " " <<datas[idxcf[4]][i] << "\n" ;
  out <<datas[idxcf[2]][i] << " " << datas[idxcf[3]][i] << " " <<datas[idxcf[4]][i] << "\n" ;
  }
out << "\nVECTORS r double\n" ;
for (i=0 ; i<nb_atomes ; i++)
  {
  out <<datas[idxcf[6]][i] << " " << datas[idxcf[7]][i] << " " <<datas[idxcf[8]][i] << "\n" ;
  out <<datas[idxcf[6]][i] << " " << datas[idxcf[7]][i] << " " <<datas[idxcf[8]][i] << "\n" ;
  }

/*out << "SCALARS pz double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {out << step.datas[step.find_idx(POSZ)][(int)datas[idxcf[0]][i]-1] << " " << step.datas[step.find_idx(POSZ)][(int)datas[idxcf[1]][i]-1]  << " " ;}


idxcf[5]=find_idx(POSZ) ;
out << "CELL_DATA " << nb_liens << "\n" ;
out << "SCALARS POSZ double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {out << datas[idxcf[5]][i] <<" " ;}

idxcf[5]=find_idx(CFR) ;
out << "SCALARS CFR double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {out << datas[idxcf[5]][i] <<" " ;}

idxcf[5]=find_idx(CFTHETA) ;
out << "SCALARS CFTHETA double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {out << datas[idxcf[5]][i] <<" " ;}

idxcf[5]=find_idx(CFPHI) ;
out << "SCALARS CFPHI double 1\n" ;
out << "LOOKUP_TABLE default\n" ;
for (i=nb_atomes-nb_liens ; i<nb_atomes ; i++)
 {out << datas[idxcf[5]][i] <<" " ;}
*/
return 1 ;
}
//-----------------------------------------
int Step::LCFatm_rotate(Matrix3x3 & rot, int id)
{
int idx[3] ;
Vector pt1(3) ;

/*idx[0]=find_idx(POSX) ; idx[1]=find_idx(POSY) ; idx[2]=find_idx(POSZ) ;
if (idx[0]!=-1 && idx[1]!=-1 && idx[2]!=-1)
   {
   pt1=Convert::toVect(datas[idx[0]][id], datas[idx[1]][id], datas[idx[2]][id]) ;
   pt1=Geometrie::rotation(pt1, rot) ;
   datas[idx[0]][id]=pt1(1,1) ; datas[idx[1]][id]=pt1(2,1) ; datas[idx[2]][id]=pt1(3,1) ;
   }

idx[0]=find_idx(CFX) ; idx[1]=find_idx(CFY) ; idx[2]=find_idx(CFZ) ;
if (idx[0]!=-1 && idx[1]!=-1 && idx[2]!=-1)
   {
   pt1=Convert::toVect(datas[idx[0]][id], datas[idx[1]][id], datas[idx[2]][id]) ;
   pt1=Geometrie::rotation(pt1, rot) ;
   datas[idx[0]][id]=pt1(1,1) ; datas[idx[1]][id]=pt1(2,1) ; datas[idx[2]][id]=pt1(3,1) ;
   }*/

idx[0]=find_idx(CFFORCEX) ; idx[1]=find_idx(CFFORCEY) ; idx[2]=find_idx(CFFORCEZ) ;
if (idx[0]!=-1 && idx[1]!=-1 && idx[2]!=-1)
   {
   pt1=Convert::toVect(datas[idx[0]][id], datas[idx[1]][id], datas[idx[2]][id]) ;
   pt1=Geometrie::rotation(pt1, rot) ;
   datas[idx[0]][id]=pt1(1) ; datas[idx[1]][id]=pt1(2) ; datas[idx[2]][id]=pt1(3) ;
   }
return 1;
}

//-----------------------------------------------
int Step::LCFcouple (Step & lstep, Vector &torque, Cylindre C) 
{
 int i, j, idx[8], natm=0 ; 
 Vector x, contact, force ; 
 double dst ; 
 
 torque(1)=torque(2)=torque(3)=0;
 
 // Ajout des colonnes nécessaires dans le ldump ; 
 lstep.nb_idx+=3 ; 
 lstep.idx_col.push_back(FORCEWALLX) ; lstep.idx_col.push_back(FORCEWALLY) ; lstep.idx_col.push_back(FORCEWALLZ) ; 
 lstep.datas.resize(lstep.idx_col.size()) ; 
 idx[0]=lstep.find_idx(FORCEWALLX) ; idx[1]=lstep.find_idx(FORCEWALLY) ; idx[2]=lstep.find_idx(FORCEWALLZ) ; 
 lstep.datas[idx[0]].resize(lstep.nb_atomes, 0) ; lstep.datas[idx[1]].resize(lstep.nb_atomes, 0) ; lstep.datas[idx[2]].resize(lstep.nb_atomes, 0) ; 
 
 //for (i=0 ; i<lstep.nb_atomes ; i++) {lstep.datas[idx[0]][i]=lstep.datas[idx[1]][i]=lstep.datas[idx[2]][i]=0 ; 
 // Force par particule due aux chaines de force grains--grains
 idx[3]=find_idx(CFID1) ; idx[4]=find_idx(CFID2) ; 
 idx[5]=find_idx(CFFORCEX) ; idx[6]=find_idx(CFFORCEY) ; idx[7]=find_idx(CFFORCEZ) ;
 for (i=0 ; i<nb_atomes ; i++)
 {
  lstep.datas[idx[0]][datas[idx[3]][i]]+=datas[idx[5]][j] ;
  lstep.datas[idx[1]][datas[idx[3]][i]]+=datas[idx[6]][j] ;
  lstep.datas[idx[2]][datas[idx[3]][i]]+=datas[idx[7]][j] ;
  
  lstep.datas[idx[0]][datas[idx[4]][i]]+=(-datas[idx[5]][j]) ;
  lstep.datas[idx[1]][datas[idx[4]][i]]+=(-datas[idx[6]][j]) ;
  lstep.datas[idx[2]][datas[idx[4]][i]]+=(-datas[idx[7]][j]) ;
 }
  
 // Ecarts de force (nul pour la plupart (ou epsilon), seuls les grains en contact avec une paroi doivent montrer quelque chose.
 idx[5]=lstep.find_idx(FX) ; idx[6]=lstep.find_idx(FY) ; idx[7]=lstep.find_idx(FZ) ;
 for (i=0 ; i<lstep.nb_atomes ; i++ )
 {lstep.datas[idx[0]][i]=lstep.datas[idx[5]][i]-lstep.datas[idx[0]][i] ;
  lstep.datas[idx[1]][i]=lstep.datas[idx[5]][i]-lstep.datas[idx[1]][i] ;
  lstep.datas[idx[2]][i]=lstep.datas[idx[5]][i]-lstep.datas[idx[2]][i] ;   
 }
 
 // Grain en contact avec le cylindre ??
 idx[5]=lstep.find_idx(POSX) ; idx[6]=lstep.find_idx(POSY) ; idx[7]=lstep.find_idx(POSZ) ;
 for (i=0 ; i<lstep.nb_atomes ; i++)
 {
  x(1)=lstep.datas[idx[5]][i]; x(2)=lstep.datas[idx[6]][i]; x(3)=lstep.datas[idx[7]][i]; 
  dst=Geometrie::distance_cylindre(C, x) ;
  if (dst < 0 ) DISP_Warn ("Erreur : des grains à l'intérieur du cylindre ????\n") ; 
  if (Geometrie::distance_cylindre(C, x) < actions.Radius)
  {
    force(1)=lstep.datas[idx[0]][i] ; force(2)=lstep.datas[idx[1]][i] ; force(3)=lstep.datas[idx[2]][i] ; 
    contact=Geometrie::contact_cylindre(C, x) ; 
    torque=torque+force.cross(contact-C.centre) ; 
    natm++ ; 
  }
 }
 
 return natm ;  
}
