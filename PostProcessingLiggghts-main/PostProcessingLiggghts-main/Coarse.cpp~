#include "Headers/Coarse.h"

// Semaphore et mutex
//sem_t nb_proc_disp ;
//pthread_mutex_t mutex_reading = PTHREAD_MUTEX_INITIALIZER;
//pthread_mutex_t mutex_wait_i = PTHREAD_MUTEX_INITIALIZER;

int CoarseDump::do_coarse (Dump &dump, Dump &dumpatm, int type)
{
long int debut, fin, step ;
int  i ; Coarse coarse_null ; 
Step stepnull ; 

if (actions["extract"].set)
   {debut=(int)actions["extract"]["extract_deb"] ; fin=(int)actions["extract"]["extract_fin"] ;
     if (debut<0) {debut=0 ; DISP_Warn("WARN : le debut de l'extraction est <0. RAZ.\n") ; }
     if ((type==0|| type==2) && fin>dump.nbsteps) {fin=dump.nbsteps ; DISP_Warn("WARNING : la fin de l'extraction est >nbsteps. Remise à nbsteps.\n") ; }
     else if (type==1 && fin>dumpatm.nbsteps) {fin=dumpatm.nbsteps ; DISP_Warn("WARNING : la fin de l'extraction est >nbsteps. Remise à nbsteps.\n") ; }  
    }
else
   {debut=0 ; if (type==0|| type==2) fin=dump.nbsteps; else fin=dumpatm.nbsteps ; }

if (actions["downsampling"].set)
   { step=(int)actions["downsampling"]["downsampling"] ; 
   if (step<=0) { step=1 ; DISP_Warn("WARN : downsampling incorrect. Remis à 1.\n") ;}
   if ((type==0|| type==2) && step>dump.nbsteps) { step=1 ; DISP_Warn("WARN : downsampling incorrect. Remis à 1.\n") ;}
   if (type == 1 && step>dumpatm.nbsteps) { step=1 ; DISP_Warn("WARN : downsampling incorrect. Remis à 1.\n") ;}
   }
else
   step=1 ;

nb_coarse=(fin-debut)/step ; 
actions.total=nb_coarse ; cout << "\nCoarseDump::do_coarse          " ; actions.disp_progress() ; 
coarse.resize(nb_coarse, coarse_null) ; 

for (i=debut ; i<fin ; i+=step)
  {
  actions.valeur=i-debut ;
  if (type==0 || type==2) dump.check_timestep(i) ; 
  if (type==1) dumpatm.check_timestep(i) ; // Normalement, si le dumpatm n'est pas seul il est écrit lors de l'appel au dumpCF
  
  if (coarse[(i-debut)/step].boites.size()==0)  // First corse, on initialise les boîtes.
     {
     if(type==1) coarse[(i-debut)/step].coarse(dumpatm.steps[i]) ; 
     else        coarse[(i-debut)/step].coarse(dump.steps[i]) ; 
     }
     
  switch(type) {
       case 0 : coarse[(i-debut)/step].do_coarse(dump.steps[i], stepnull, type) ; break ; 
       case 1 : coarse[(i-debut)/step].do_coarse(stepnull, dumpatm.steps[i], type) ; break ; 
       case 2 : coarse[(i-debut)/step].do_coarse(dump.steps[i], dumpatm.steps[i], type) ; break ; 
       }
  }
  
return 1 ;
}

//-----------------------------------------------
Coarse CoarseDump::mean(void)
{
Coarse tmp ; int i, j ; 
tmp=coarse[0] ; 
if (coarse[0].useCF)
  tmp.useCF=true ; 

tmp.boites.resize(tmp.nb_boites_tot) ;

for (i=0 ; i<tmp.nb_boites_tot ; i++)
  {tmp.boites[i]=coarse[0].boites[i] ;}
for (i=1 ; i<nb_coarse ; i++)
  {
  for (j=0 ; j<coarse[i].nb_boites_tot ; j++)
      {
      tmp.boites[j]=tmp.boites[j]+coarse[i].boites[j] ; 
      }
  }
for (i=0 ; i<tmp.nb_boites_tot ; i++)
   {
   tmp.boites[i].phi/=nb_coarse ;
   tmp.boites[i].vx/=nb_coarse ;
   tmp.boites[i].vy/=nb_coarse ;
   tmp.boites[i].vz/=nb_coarse ;
   tmp.boites[i].nb_atomes/=nb_coarse ;
   tmp.boites[i].nb_contacts/=nb_coarse ;
   tmp.boites[i].sigma=tmp.boites[i].sigma/nb_coarse ;
   tmp.boites[i].sigmak=tmp.boites[i].sigmak/nb_coarse ;
   tmp.boites[i].sigmatot=tmp.boites[i].sigmatot/nb_coarse ;
   tmp.boites[i].mean_radius=tmp.boites[i].mean_radius/nb_coarse ;
  }
return tmp ; 
}
//------------------------------------------------
int CoarseDump::write(string chemin)
{
long int loop[3] ;
int ts, i; 
Writing * W ;
bool stop ; 

W=&(actions.ecrire) ; 
W->chemin=&(chemin) ; 

pthread_mutex_init(&W->mutex, NULL);
pthread_cond_init (&W->sigin, NULL);
pthread_cond_init (&W->sigout, NULL);
pthread_mutex_lock(&W->mutex);
W->startall() ; 

stop=false ; 
loopdat(loop) ;
cout << "Coarse::write       " ;
open("") ; 
actions.total=loop[2]-loop[0] ; actions.disp_progress() ;
while (stop==false) 
{
  pthread_cond_wait(&W->sigout, &W->mutex);
  switch (W->Signal)
  {
    case WHATAREYOU : W->sendin(COARSEDUMP) ; break ;
    case ASKINGGRID : W->i=coarse[ts].nb_boites ; W->sendin(OK) ; break ; 
    case FIRSTTS : ts=loop[0] ; W->i=&ts ; check_timestep(ts) ; W->sendin(OK) ; break ;
    case CHOOSELDUMP : W->sendin(OK) ; break ; 
    case CHOOSECFDUMP : W->sendin(UNABLE) ;  break ; 
    case NEXTTS : 
      ts+=loop[1] ; actions.valeur=ts-loop[0] ; 
      if (ts>=loop[2]) 
	{ts=-1 ; W->i=&ts ; W->sendin(FINISH) ; } 
      else 
	{check_timestep(ts) ; W->i=&ts ; W->sendin(OK) ; }
      break ; 
    case ASKING1D : 
      W->d[0]=&(steps[ts].datas[steps[ts].find_idx(*(W->i))][0]) ; W->i=&steps[ts].nb_atomes ; W->sendin(OK) ; break ;  
    case ASKING2D : 
      for (i=0 ; i<3 ; i++) 
        W->d[i]=&(steps[ts].datas[steps[ts].find_idx(*(W->i+i))][0]) ; 
      W->i=&steps[ts].nb_atomes ; W->sendin(OK) ; break ;  
    case ASKING3D : 
      for (i=0 ; i<9 ; i++) 
	W->d[i]=&(steps[ts].datas[steps[ts].find_idx(*(W->i+i))][0]) ; 
      W->i=&steps[ts].nb_atomes ; W->sendin(OK) ; break ;  
    case ASKINGND : 
      for (i=0 ; *(W->i+i)!=-1 ; i++) 
	W->d[i]=&(steps[ts].datas[steps[ts].find_idx(*(W->i+i))][0]) ; 
      W->i=&steps[ts].nb_atomes ; W->sendin(OK) ; break ;    
    case FINI : stop=true ; W->sendin(OK) ; break ; 
    default : DISP_Warn("Signal d'écriture inconnu"); break ; 
  }
}
return 1 ;   
}
/*W->generate_coarsemap(*this) ; // Création de la carte pour les champs du coarse

if (W->get_typeset("coarse:vtk")) // have to write all vtk
{ 
 cout << "CoarseDump::write          " ; 
 actions.total=nb_coarse ; actions.disp_progress() ;
 datas=(double **) malloc(sizeof(double *)*9) ; 
 for (j=0 ; j<9 ; j++)
    datas[j]=(double *) malloc(coarse[0].nb_boites_tot*sizeof (double)) ; 
 for (i=0 ; i<nb_coarse ; i++)
 {
  actions.valeur=i ;
  sprintf(strnum, "%d", i) ; chemin2=chemin+"-"+strnum+"-coarse.vtk" ; 
  out.open(chemin2.c_str(), ios::out) ;
  // Ecriture des points centraux des boites
  for (itb=0 ; (itb); itb++)
    for (j=0 ; j<3 ; j++)
      datas[j][itb.idx()]=coarse[i].boites[(int)itb].x0(j+1) ;
    
  W->VTKStructuredGrid(out, datas, coarse[i].nb_boites_tot, coarse[i].nb_boites) ; 
  W->VTKStartPointData(out, coarse[i].nb_boites_tot) ; 
  
  while ( (res=W->get_nextfield("coarse:vtk"))  != -1)
  {
    it=W->dim.begin() ; std::advance(it,res);
    
    for (j=0 ; (res2=W->get_nextname(it->first)).compare("false") ; j++)
    {
      for (itb=0 ; itb ; itb++)
	datas[j][itb.idx()]=*(coarse[i].boites[(int)itb].carte[res2]) ; 
    }
    
    W->VTKField(out, it->first, datas, it->second, coarse[i].nb_boites_tot) ; 
  }
  out.close() ; 
 }
   for (j=0 ; j<9 ; j++) free(datas[j]) ; 
  free(datas) ;
}
    
if (W->get_typeset("coarse:mat")) // have to write a matlab 
{
#ifdef MATLAB  
 MATFile * mout ; 
 cout << "CoarseDump::write          " ; 
 actions.total=nb_coarse ; actions.disp_progress() ;
 
 // Allocation mémoire
 for (i=0 ; (res=W->get_nextfield("coarse:mat")) != -1 ; i++)
  {
    it=W->dim.begin() ; std::advance(it,res);
    //printf("Allocation de %d double\n",coarse[0].nb_boites_tot*W->get_numelem(it->first)*(nb_coarse)) ;
    if (i==0) datas=(double **) malloc ((i+1)*sizeof(double *)) ; 
    else datas=(double **) realloc(datas, (i+1)*sizeof(double *)) ; 
    datas[i] = (double *) mxCalloc(coarse[0].nb_boites_tot*W->get_numelem(it->first)*(nb_coarse), sizeof(double));
  }
 for (i=0 ; i<nb_coarse ; i++)
 {
  actions.valeur=i ; // dat[var][atm,dim,ts]
  
  for (v=0 ; (res=W->get_nextfield("coarse:mat")) != -1 ; v++)
  {
    it=W->dim.begin() ; std::advance(it,res);
    for (j=0 ; (res2=W->get_nextname(it->first)).compare("false") ; j++)
     for (k=0 ; k<coarse[i].nb_boites_tot ; k++)
      datas[v][i*W->get_numelem(it->first)*coarse[i].nb_boites_tot + j*coarse[i].nb_boites_tot + k] = *(coarse[i].boites[k].carte[res2]) ;  
  }
 }
 
 chemin2=chemin+"-coarse.mat" ; 
 mout=matOpen(chemin2.c_str(), "w");
 double *dims ; dims=(double *)mxCalloc(3, sizeof(double)) ; dims[0]=coarse[0].nb_boites[0] ; dims[1]=coarse[0].nb_boites[1] ; dims[2]=coarse[0].nb_boites[2] ; 
 W->MATMatrix (mout, "dimensions", dims, 1, 3) ;
 for (j=0 ; (res=W->get_nextfield("coarse:mat")) != -1 ; j++)
 {
  it=W->dim.begin() ; std::advance(it,res);
  W->MATMatrix (mout, it->first, datas[j], 3, coarse[0].nb_boites_tot, W->get_numelem(it->first), nb_coarse) ; 
 }
 matClose(mout) ; 
 for (i=0 ; (res=W->get_nextfield("coarse:mat")) != -1 ; i++) mxFree(datas[i]) ; 
 free(datas) ;
#else
 DISP_Warn ("Le programme n'a pas été compilé avec le support matlab. Pas de fichier mat écrit.\n") ; 
#endif   
}
return 1 ; */   

/*
int CoarseDump::write(string chemin)
{
int i, debut ;
ofstream out ; 
stringstream chemin2 ;

if (actions["extract"].set) debut=actions["extract"]["extract_deb"] ;
else debut=0 ;

for (i=0 ; i<nb_coarse ; i++)
  {
  chemin2.str("") ; 
  chemin2 << chemin << "-" << i+debut << "-coarse.vtk" ;
  out.open(chemin2.str().c_str(), ios::out) ; 
  coarse[i].write_asVTK(out) ; 
  out.close() ; 
  }
return 1 ;
}*/
//-----------------------------------------------
int CoarseDump::write_asMatlabSpatioTemp (string chemin)
{
int i, j, debut ;
ofstream out ; 
stringstream chemin2 ;

if (actions["extract"].set) debut=actions["extract"]["extract_deb"] ;
else debut=0 ;

chemin2.str("") ; chemin2 << chemin << "-spatiotemp.mat" ;
out.open(chemin2.str().c_str(), ios::out) ; 
for (i=0 ; i<nb_coarse ; i++)
  {
   for (j=0 ; j<coarse[i].nb_boites[1] ; j++)
   {
     out << coarse[i].boites[coarse[i].linidx(coarse[i].nb_boites[0]/2,j,0)].vx << " " ;
   }
  out << "\n" ;  
  }
return 1 ; 
}

//-----------------------------------------------
int CoarseDump::write_asMatlab (string chemin)
{
int i ; 
DISP_Err("Coarse Matlab non implémenté\n") ;
/*ofstream out_box, out_atm, out_vx, out_vy, out_vz ;
stringstream chemin2 ;

chemin2.str("") ; chemin2 << chemin << "-" << "boites.vtk" ;  
out_box.open(chemin2.str().c_str(), ios::out) ;
for (i=0 ; i<coarse[0].nb_boites_tot ; i++)
  {
  //out_box << coarse[0].boites[i].x << " " ; 
  //out_box << coarse[0].boites[i].y << " " ;
  //out_box << coarse[0].boites[i].z << "\n" ;
  out_box << coarse[0].boites[i].x0(1) << " " << coarse[0].boites[i].x0(2) << " " << coarse[0].boites[i].x0(3) << "\n" ;
  }
out_box.close() ; 

chemin2.str("") ; chemin2 << chemin << "-" << "atm.vtk" ;  
out_atm.open(chemin2.str().c_str(), ios::out) ;
chemin2.str("") ; chemin2 << chemin << "-" << "vx.vtk" ;  
out_vx.open(chemin2.str().c_str(), ios::out) ;
chemin2.str("") ; chemin2 << chemin << "-" << "vy.vtk" ;  
out_vy.open(chemin2.str().c_str(), ios::out) ;
chemin2.str("") ; chemin2 << chemin << "-" << "vz.vtk" ;  
out_vz.open(chemin2.str().c_str(), ios::out) ;



for (i=0 ; i<nb_coarse ; i++)
  { 
  coarse[i].write_asMatlab(out_atm, out_vx, out_vy, out_vz) ; 
  out_atm<<"\n" ; 
  out_vx <<"\n" ; 
  out_vy <<"\n" ; 
  out_vz <<"\n" ;
  }

out_atm.close() ; out_vx.close() ; out_vy.close() ; out_vz.close() ; 
*/
return 1 ;
}


//============================================================
//============================================================
Coarse::Coarse ()
{
 nb_boites_tot=0 ; 
}
//------------------------------------------------------------
int Coarse::coarse (Step &step)
{
int j, k, l; Vector tailles ; 
bool specatm=false, speccf=false ; 
static bool infofenetre=true ;
static bool showwarn=true ;
static unsigned char infobox=0 ;

if (actions["use-box"].set)
    {
	if (actions["use-box"]["box_xmin"]<step.box[0][0]) {infobox|=32 ; borders[0][0]=step.box[0][0]; } else {borders[0][0]=actions["use-box"]["box_xmin"] ;}
	if (actions["use-box"]["box_xmax"]>step.box[0][1]) {infobox|=16 ; borders[0][1]=step.box[0][1]; } else {borders[0][1]=actions["use-box"]["box_xmax"] ;}
	if (actions["use-box"]["box_ymin"]<step.box[1][0]) {infobox|=8  ; borders[1][0]=step.box[1][0]; } else {borders[1][0]=actions["use-box"]["box_ymin"] ;}
	if (actions["use-box"]["box_ymax"]>step.box[1][1]) {infobox|=4  ; borders[1][1]=step.box[1][1]; } else {borders[1][1]=actions["use-box"]["box_ymax"] ;}
	if (actions["use-box"]["box_zmin"]<step.box[2][0]) {infobox|=2  ; borders[2][0]=step.box[2][0]; } else {borders[2][0]=actions["use-box"]["box_zmin"] ;}
	if (actions["use-box"]["box_zmax"]>step.box[2][1]) {infobox|=1  ; borders[2][1]=step.box[2][1]; } else {borders[2][1]=actions["use-box"]["box_zmax"] ;}

	if ((infobox > 0)  && (!(infobox & 128))) {DISP_Info("\nUse-box plus grand que la simu : ") ; printf("0x%x\n", infobox) ;  infobox|=128 ; }

    }
else
    {
    borders[0][0]=step.box[0][0] ; borders[0][1]=step.box[0][1] ; borders[1][0]=step.box[1][0] ; 
    borders[1][1]=step.box[1][1] ; borders[2][0]=step.box[2][0] ; borders[2][1]=step.box[2][1] ;
    }

nb_boites[0]=actions["coarse-graining"]["nbbox_x"] ; 
nb_boites[1]=actions["coarse-graining"]["nbbox_y"] ;
nb_boites[2]=actions["coarse-graining"]["nbbox_z"] ;
nb_boites_tot=nb_boites[0]*nb_boites[1]*nb_boites[2] ; 
boites.resize(nb_boites_tot) ;
// Ecriture des données de boîtes
// Initialisation du fenêtrage ...

// Par default : fenêtre0 est winsphere (moyennage des atomes)
//               fenetre est creneau3D                 

if (actions["wingauss"].set)
   {
   DISP_Warn("Ne devrait pas être utilisé. Par defaut, winsphere pour les coarse ATM, creneau3D pour les coarse CF") ;   
   specatm=speccf=true ; 
   fenetre=&Fonction::int_gaussienne3D ; 
   fenetreO=&Fonction::gaussienne3D ; 
   if (actions["wingauss"]["sigma"]==-1)
      {
      cout << "Attention : le calcul automatique du sigma pour une wingauss simple ne se fait qu'à partir du nombre de boîte dans la dimension x" ;
      tailles=taille_boite(step) ; 
      sigmafenetre(1)=sigmafenetre(2)=sigmafenetre(3)=1/sqrt(2)*tailles(1) ;
      }
   else
      {sigmafenetre(1)=sigmafenetre(2)=sigmafenetre(3)=actions["wingauss"]["sigma"] ; }
   sigmafenetreO=sigmafenetre ;
   }
if (actions["wingauss3D"].set)
   { DISP_Err("WINGAUSS3D not implemented") ; } 
if (actions["wincreneau"].set)
   {
   fenetreO=&Fonction::creneau3D ; 
   sigmafenetreO=taille_boite(step) ;
   DISP_Warn("Win creneau pas clair ...") ; 
   }
   
// Default case   
if (specatm==false)
   {
   if (infofenetre) {
	DISP_Info("Attention : pour le coarsening sur une fenêtre sphérique, le diamètre de la sphère est la plus petite dimension du pas spatial.\n") ;
	DISP_Info("Attention à renseigner correctement la valeur de Actions.Radius : ") ; cout << actions.Radius*1000*1000  ; DISP_Info("um !!!!\n") ;
	}
   tailles=taille_boite(step) ;
   tailles(1)=tailles(1)>tailles(2)?tailles(2):tailles(1) ;
   if (!actions["is2D"].set) tailles(1)=tailles(1)>tailles(3)?tailles(3):tailles(1) ;
   sigmafenetreO(1)=sigmafenetreO(2)=sigmafenetreO(3)=tailles(1)/2.0 ;

   if (infofenetre) {
        DISP_Info("Attention : pour le coarsening sur une fenêtre sphérique, le diamètre de la sphère est la plus petite dimension du pas spatial : ") ;
	cout << sigmafenetreO(1)*1000*2 ; DISP_Info("mm.\n") ; }
   if (sigmafenetreO(1)<actions.Radius) {DISP_Warn("Attention : la taille de la sphère de moyennage est plus petite que le rayon des atomes") ;}

   //fenetre=&Fonction::int_intersect_sphere ;
   if (actions["is2D"].set) fenetreO=&Fonction::intersect_cercle ;
   else fenetreO=&Fonction::intersect_sphere ;
   specatm=true ;  
   }  
if (speccf==false)
   {
   // Fonction créneau 3D
   if (actions["is2D"].set) { if (infofenetre){DISP_Info("Chainforce fenetre creneau 2D\n") ;} fenetre = &Fonction::int_creneau2D ; }
   else {fenetre=&Fonction::int_creneau3D ; }

   sigmafenetre=taille_boite(step) ;

   if (actions["winboxyper"].set)
   	   { if (nb_boites[1]>1 || (actions["use-box"].set && ((borders[1][1]-borders[1][0])<(step.box[1][1]-step.box[1][0]))))
   	     { DISP_Warn("A VERIFIER !!!!! Attention, pour une boite y periodique, la taille en y devrait être égale à l'épaisseur de la boite de simu, et il ne devrait y avoir qu'une seulle boite en y\n") ;
   	     }
   	   }
   if (showwarn && (sigmafenetre(1)<actions.Radius || sigmafenetre(2)<actions.Radius || (sigmafenetre(3)<actions.Radius && (!actions["is2D"].set))))
	   {DISP_Warn("Attention, l'une des dimension de la boîte de moyennage est inéfrieur au rayon des atomes"); showwarn=false ; }
   speccf=true ; 	   
   }
   
infofenetre=false ;    
   
for (j=0 ; j<nb_boites[0] ; j++)
  {
    for (k=0 ; k<nb_boites[1] ; k++)
    {
     for (l=0 ; l<nb_boites[2] ; l++)
      {
      boites[linidx(j,k,l)].x0(1)=(j+0.5)*(borders[0][1]-borders[0][0])/(double)nb_boites[0]+borders[0][0] ; 
      boites[linidx(j,k,l)].x0(2)=(k+0.5)*(borders[1][1]-borders[1][0])/(double)nb_boites[1]+borders[1][0] ; 
      boites[linidx(j,k,l)].x0(3)=(l+0.5)*(borders[2][1]-borders[2][0])/(double)nb_boites[2]+borders[2][0] ; 

      boites[linidx(j,k,l)].phi=0 ;
      boites[linidx(j,k,l)].mean_radius=0 ;

      boites[linidx(j,k,l)].nb_atomes=boites[linidx(j,k,l)].nb_contacts=0 ; 
      boites[linidx(j,k,l)].vx=boites[linidx(j,k,l)].vy=boites[linidx(j,k,l)].vz=0 ;
      boites[linidx(j,k,l)].sigma=0.0 ; boites[linidx(j,k,l)].sigmak=0.0 ; boites[linidx(j,k,l)].sigmatot=0.0 ;
      }
    }
  }  
return 1 ;
}

//-------------------------------------------------
Vector & Coarse::taille_boite (Step &step)
{
double borders[3][2] ;
Vector *retour=new Vector ; 

if (actions["use-box"].set)
    {
	if (actions["use-box"]["box_xmin"]<step.box[0][0]) {borders[0][0]=step.box[0][0]; } else {borders[0][0]=actions["use-box"]["box_xmin"] ;}
	if (actions["use-box"]["box_xmax"]>step.box[0][1]) {borders[0][1]=step.box[0][1]; } else {borders[0][1]=actions["use-box"]["box_xmax"] ;}
	if (actions["use-box"]["box_ymin"]<step.box[1][0]) {borders[1][0]=step.box[1][0]; } else {borders[1][0]=actions["use-box"]["box_ymin"] ;}
	if (actions["use-box"]["box_ymax"]>step.box[1][1]) {borders[1][1]=step.box[1][1]; } else {borders[1][1]=actions["use-box"]["box_ymax"] ;}
	if (actions["use-box"]["box_zmin"]<step.box[2][0]) {borders[2][0]=step.box[2][0]; } else {borders[2][0]=actions["use-box"]["box_zmin"] ;}
	if (actions["use-box"]["box_zmax"]>step.box[2][1]) {borders[2][1]=step.box[2][1]; } else {borders[2][1]=actions["use-box"]["box_zmax"] ;}
    }
else
    {
    borders[0][0]=step.box[0][0] ; borders[0][1]=step.box[0][1] ; borders[1][0]=step.box[1][0] ; 
    borders[1][1]=step.box[1][1] ; borders[2][0]=step.box[2][0] ; borders[2][1]=step.box[2][1] ;
    }

(*retour)(1)=(borders[0][1]-borders[0][0])/(double)actions["coarse-graining"]["nbbox_x"] ;
(*retour)(2)=(borders[1][1]-borders[1][0])/(double)actions["coarse-graining"]["nbbox_y"] ;
(*retour)(3)=(borders[2][1]-borders[2][0])/(double)actions["coarse-graining"]["nbbox_z"] ;
return (*retour) ; 
}

//==========================================================================
Coarse operator+(Coarse c1, Coarse c2)
{
 int i ; Coarse temp ;  
 
 // Check que les deux coarse sont compatibles
 if (c1==c2)
   temp=c1 ;  
 else
   {
   cout << "ERR : tentative d'addition de deux coarse n'ayant pas des propriétés identiques" ;
   return temp ; 
   }
 
 for (i=0 ; i<temp.nb_boites_tot ; i++)
 {
 temp.boites[i]=c1.boites[i]+c2.boites[i] ; 
 }
 
 return temp ; 
}

//---------------------------------------------------
void Coarse::operator=(Coarse c)
{
 int j ; 
 nb_boites_tot=c.nb_boites_tot ; 
 nb_boites[0]=c.nb_boites[0] ; nb_boites[1]=c.nb_boites[1] ; nb_boites[2]=c.nb_boites[2] ;  
 borders[0][0]=c.borders[0][0] ; borders[0][1]=c.borders[0][1] ; borders[1][0]=c.borders[1][0] ; 
 borders[1][1]=c.borders[1][1] ; borders[2][0]=c.borders[2][0] ; borders[2][1]=c.borders[2][1] ; 
 boites.resize(nb_boites_tot) ; 
 
 for (j=0 ; j<nb_boites_tot ; j++)
 {boites[j]=c.boites[j] ; }  
}

//----------------------------------------------------
bool operator==(Coarse c1, Coarse c2)
{
  if (c1.nb_boites[0]==c2.nb_boites[0] && c1.nb_boites[1]==c2.nb_boites[1] && c1.nb_boites[2]==c2.nb_boites[2]
    && c1.borders[0][0]==c2.borders[0][0] && c1.borders[0][1]==c2.borders[0][1] && c1.borders[1][0]==c2.borders[1][0]
    && c1.borders[1][1]==c2.borders[1][1] && c1.borders[2][0]==c2.borders[2][0] && c1.borders[2][1]==c2.borders[2][1])
    return true ; 
  else
    return false ;   
}

//==========================================================================
int Coarse::do_coarse(Step &step, Step &stepatm, int type) // On fait les 2 coarse en même temps.
{
int j, k, l ; 
double width, height, depth, rayon, masse ;
int idx[9], idxatm[7], idxlin[2] ; 
static bool infoonce=true ; 
Vector r, f, xa, xb ; 

// 1 : checks du type de coarse 0 cfcoarse seulement (cannot do w/kinetic), 1 atmcoarse seul, 2 both
if (type== 1 && actions["w/kinetic"].set )
   {DISP_Err("ERR: impossible de calculer les contraintes cinétiques sans dump atomique");
    return 1 ; }
switch(type) {
  case 0 : if (step.Type!=TCF) {DISP_Err("ERR: impossible de calculer les contraintes. Types de step incorrects"); return 2 ;} break;
  case 1 : if (stepatm.Type!=TL) {DISP_Err("ERR: impossible de calculer les vitesses. Types de step incorrects"); return 2 ;} break ; 
  case 2 : if (step.Type!=TCF && stepatm.Type!=TL) {DISP_Err("ERR: impossible de calculer les contraintes. Types de step incorrects"); return 2 ;} break ;
  }
    
// 2 : récupération des indexes  
if (type==0 || type==2)
  {
  idx[0]=step.find_idx(POSX)     ; idx[1]=step.find_idx(POSY)     ; idx[2]=step.find_idx(POSZ) ;
  idx[3]=step.find_idx(CFX)      ; idx[4]=step.find_idx(CFY)      ; idx[5]=step.find_idx(CFZ) ;
  idx[6]=step.find_idx(CFFORCEX) ; idx[7]=step.find_idx(CFFORCEY) ; idx[8]=step.find_idx(CFFORCEZ) ;
  for (j=0 ; j<9 ; j++) { if (idx[j]==-1) { DISP_Err ("ERR: donnees manquantes pour le coarse graining\n") ; return 3 ;}}
  }
if (type==1 || type==2)
  {
  idxatm[0]=stepatm.find_idx(POSX) ; idxatm[1]=stepatm.find_idx(POSY)  ; idxatm[2]=stepatm.find_idx(POSZ) ;
  idxatm[3]=stepatm.find_idx(VX)   ; idxatm[4]=stepatm.find_idx(VY)    ; idxatm[5]=stepatm.find_idx(VZ) ; 
  for (j=0 ; j<6 ; j++) { if (idxatm[j]==-1) { DISP_Err ("ERR: donnees manquantes pour le coarse graining\n") ; printf("[%d %d]\n",step.timestep, stepatm.timestep) ;  return 3 ;}}
  
  idxatm[6]=stepatm.find_idx(RAYON) ;
  if (idxatm[6]==-1)
    {
    if (infoonce)
    {
      DISP_Info("Pas de données de RAYON. Le rayon atm utilisé pour le coarse graining est : ") ; 
      printf("%f\n", actions.Radius) ;  
      infoonce=false ; 
    }
    rayon=actions.Radius ; 
    }
  }

// 3 : coarse graining pour vitesses si nécessaire pour commencer
double coeff ; Vector position ; 
int natomescompt=stepatm.nb_atomes  ;
int bidx[3], idxclosest, ii, jj, kk, bornes[6] ;
Vector vitesse, vitesset ;
int DeltaBoites=1 ; // TODO Compute deltaboite
if (type==1 || type==2)
 {
 for (j=0 ; j<natomescompt ; j++)
  {
  position(1)=stepatm.datas[idxatm[0]][j] ; position(2)=stepatm.datas[idxatm[1]][j] ; position(3)=stepatm.datas[idxatm[2]][j] ; 
  calc_bornes(position(1), position(2), position(3), DeltaBoites, bornes) ; 
  for (ii=bornes[0] ; ii<=bornes[1] ; ii++)
   {
   for (jj=bornes[2] ; jj<=bornes[3] ; jj++)
    {
    for (kk=bornes[4] ; kk<=bornes[5] ; kk++)
     {
     idxclosest=linidx(ii, jj, kk) ;
     xa=position-boites[idxclosest].x0 ;
     if (idxatm[6]!=-1) {rayon=stepatm.datas[idxatm[6]][j] ;}
     fenetreO(coeff, xa, sigmafenetreO, rayon) ;
     
     if (actions["is2D"].set) masse=M_PI*actions.Rhograin*rayon*rayon ;
     else masse=4/3.*M_PI*actions.Rhograin*rayon*rayon*rayon ;
    
     boites[idxclosest].nb_atomes+=coeff ;
     boites[idxclosest].mean_radius+=rayon*coeff ;
     boites[idxclosest].phi+=coeff*masse ; 
     boites[idxclosest].vx+=stepatm.datas[idxatm[3]][j]*coeff*masse ;
     boites[idxclosest].vy+=stepatm.datas[idxatm[4]][j]*coeff*masse ;
     boites[idxclosest].vz+=stepatm.datas[idxatm[5]][j]*coeff*masse ;
     }
    }
   }
  }
 for (j=0 ; j<nb_boites_tot ; j++)
  {
  boites[j].phi=boites[j].phi/actions.Rhograin ;
  if (boites[j].nb_atomes>0)
     {
     boites[j].mean_radius=boites[j].mean_radius/boites[j].nb_atomes ;
     boites[j].vx=boites[j].vx/(boites[j].phi*actions.Rhograin) ;
     boites[j].vy=boites[j].vy/(boites[j].phi*actions.Rhograin) ;
     boites[j].vz=boites[j].vz/(boites[j].phi*actions.Rhograin) ;
     }
  }
 } 
  
// 4 : calcul de la contrainte cinétique si besoin 
if ((type==1 || type==2) && actions["w/kinetic"].set)
 {
 for (j=0 ; j<natomescompt ; j++)
  {
  position(1)=stepatm.datas[idxatm[0]][j] ; position(2)=stepatm.datas[idxatm[1]][j] ; position(3)=stepatm.datas[idxatm[2]][j] ; 
  calc_bornes(position(1), position(2), position(3), DeltaBoites, bornes) ; 
  for (ii=bornes[0] ; ii<=bornes[1] ; ii++)
   {
   for (jj=bornes[2] ; jj<=bornes[3] ; jj++)
    {
    for (kk=bornes[4] ; kk<=bornes[5] ; kk++)
     {
     idxclosest=linidx(ii, jj, kk) ;
     xa=position-boites[idxclosest].x0 ;
     if (idxatm[6]!=-1) {rayon=stepatm.datas[idxatm[6]][j] ;}
     fenetreO(coeff, xa, sigmafenetreO, rayon) ;
     
     if (actions["is2D"].set) masse=M_PI*actions.Rhograin*rayon*rayon ;
     else masse=4/3.*M_PI*actions.Rhograin*rayon*rayon*rayon ;

     vitesse(1)=stepatm.datas[idxatm[3]][j]-boites[idxclosest].vx ; 
     vitesse(2)=stepatm.datas[idxatm[4]][j]-boites[idxclosest].vy ; 
     vitesse(3)=stepatm.datas[idxatm[5]][j]-boites[idxclosest].vz ;
     vitesset=vitesse.t() ;
     boites[idxclosest].sigmak=(vitesse.multiply(vitesset))*coeff*masse*(-1)+boites[idxclosest].sigmak ; 
     }
    }
   }
  }
 } 
 
// 5 : coarse de forces si besoin
natomescompt=step.nb_atomes  ;
f=f.t() ;  
if (type==0 || type==2)
{
 for (j=0 ; j<natomescompt ; j++)
  {
  position(1)=step.datas[idx[0]][j] ; position(2)=step.datas[idx[1]][j] ; position(3)=step.datas[idx[2]][j] ; 
  calc_bornes(position(1), position(2), position(3), DeltaBoites, bornes) ; 
  for (ii=bornes[0] ; ii<=bornes[1] ; ii++)
   {
   for (jj=bornes[2] ; jj<=bornes[3] ; jj++)
    {
    for (kk=bornes[4] ; kk<=bornes[5] ; kk++)
     {
     idxclosest=linidx(ii, jj, kk) ;  
     f(1)=step.datas[idx[6]][j] ; f(2)=step.datas[idx[7]][j] ; f(3)=step.datas[idx[8]][j] ;
     r(1)=step.datas[idx[3]][j] ; r(2)=step.datas[idx[4]][j] ; r(3)=step.datas[idx[5]][j] ;
     xa=r/(-2.0)+position-boites[idxclosest].x0 ; xb=r/2.+position-boites[idxclosest].x0 ; 
     fenetre(coeff,xa, xb, sigmafenetre) ; 
     boites[idxclosest].sigma=(r.multiply(f))*coeff*(-1)+boites[idxclosest].sigma ;
     boites[idxclosest].nb_contacts+=coeff;
     }
    }
   }       
  }
}  
 

for (j=0 ; j<nb_boites_tot ; j++)
  {
  boites[j].sigmatot=boites[j].sigma+boites[j].sigmak ;
  }
return 1 ; 
}
//--------------------
void Coarse::calc_bornes (double x, double y, double z, int DeltaBoites, int * bornes)
{
int bidx[3] ; 
bidx[0]=floor((x-borders[0][0])/(double)((borders[0][1]-borders[0][0])/(double)nb_boites[0])) ; 
bidx[1]=floor((y-borders[1][0])/(double)((borders[1][1]-borders[1][0])/(double)nb_boites[1])) ; 
bidx[2]=floor((z-borders[2][0])/(double)((borders[2][1]-borders[2][0])/(double)nb_boites[2])) ; 
bornes[0]=((bidx[0]-DeltaBoites)<0?0:(bidx[0]-DeltaBoites)) ;
bornes[2]=((bidx[1]-DeltaBoites)<0?0:(bidx[1]-DeltaBoites)) ;
bornes[4]=((bidx[2]-DeltaBoites)<0?0:(bidx[2]-DeltaBoites)) ;
bornes[1]=((bidx[0]+DeltaBoites)>=nb_boites[0]?(nb_boites[0]-1):(bidx[0]+DeltaBoites)) ;
bornes[3]=((bidx[1]+DeltaBoites)>=nb_boites[1]?(nb_boites[1]-1):(bidx[1]+DeltaBoites)) ;
bornes[5]=((bidx[2]+DeltaBoites)>=nb_boites[2]?(nb_boites[2]-1):(bidx[2]+DeltaBoites)) ;
}

/*int Coarse::do_coarse(Step &step)
{
int j, k, l ; 
double width, height, depth ;
int idx[9], idxlin[2] ; 
Vector r, f, xa, xb ; 

idx[0]=step.find_idx(POSX) ;
idx[1]=step.find_idx(POSY) ;
idx[2]=step.find_idx(POSZ) ;
if (step.Type==TL)
  {
  idx[3]=step.find_idx(VX) ;
  idx[4]=step.find_idx(VY) ;
  idx[5]=step.find_idx(VZ) ;  
  for (j=0 ; j<6 ; j++)
   {
   if (idx[j]==0)
   {cout << "ERR2 : donnée n°" << j <<"(ordre : x y z vx vy vz) manquante. Impossible de faire le coarse graining.\n"; return 0 ; }
   }
  }
else if (step.Type==TCF)
  {
  useCF=true ; 
  idx[3]=step.find_idx(CFX) ;
  idx[4]=step.find_idx(CFY) ;
  idx[5]=step.find_idx(CFZ) ;
  idx[6]=step.find_idx(CFFORCEX) ;
  idx[7]=step.find_idx(CFFORCEY) ;
  idx[8]=step.find_idx(CFFORCEZ) ;
  }
else
  {cout << "ERR: ne peut pas faire le coarse grain pour ce type de dump" ; return 0;} 

// Parcours de tous les atomes  
double coeff ; Vector position ; 
const int natomescompt=step.nb_atomes  ;
int bidx[3], idxclosest, ii, jj, kk, bornes[3][2] ; Matrix3x3 sigmatmp ;
Vector vitesse, vitesset ;
int DeltaBoites=1 ;
f=f.t() ; 
for (j=0 ; j<natomescompt ; j++)
  {
  //if (actions["periodicity"].set && step.Type==TCF && step.datas[step.find_idx(CFPERIOD)][j]==1) continue ;
  position(1)=step.datas[idx[0]][j] ; position(2)=step.datas[idx[1]][j] ; position(3)=step.datas[idx[2]][j] ; 
  // Parcours des boites
  bidx[0]=floor((step.datas[idx[0]][j]-borders[0][0])/(double)((borders[0][1]-borders[0][0])/(double)nb_boites[0])) ; 
  bidx[1]=floor((step.datas[idx[1]][j]-borders[1][0])/(double)((borders[1][1]-borders[1][0])/(double)nb_boites[1])) ; 
  bidx[2]=floor((step.datas[idx[2]][j]-borders[2][0])/(double)((borders[2][1]-borders[2][0])/(double)nb_boites[2])) ; 
  idxclosest=linidx(bidx[0], bidx[1],bidx[2]) ;
  bornes[0][0]=((bidx[0]-DeltaBoites)<0?0:(bidx[0]-DeltaBoites)) ;
  bornes[1][0]=((bidx[1]-DeltaBoites)<0?0:(bidx[1]-DeltaBoites)) ;
  bornes[2][0]=((bidx[2]-DeltaBoites)<0?0:(bidx[2]-DeltaBoites)) ;
  bornes[0][1]=((bidx[0]+DeltaBoites)>=nb_boites[0]?(nb_boites[0]-1):(bidx[0]+DeltaBoites)) ;
  bornes[1][1]=((bidx[1]+DeltaBoites)>=nb_boites[1]?(nb_boites[1]-1):(bidx[1]+DeltaBoites)) ;
  bornes[2][1]=((bidx[2]+DeltaBoites)>=nb_boites[2]?(nb_boites[2]-1):(bidx[2]+DeltaBoites)) ;
  for (ii=bornes[0][0] ; ii<=bornes[0][1] ; ii++)
   {
   for (jj=bornes[1][0] ; jj<=bornes[1][1] ; jj++)
    {
    for (kk=bornes[2][0] ; kk<=bornes[2][1] ; kk++)
     {
     idxclosest=linidx(ii, jj, kk) ;
     if (step.Type==TL)
       {
       xa=position-boites[idxclosest].x0 ;
       fenetreO(coeff, xa, sigmafenetre) ;
       //if (coeff==0) continue ; 
       boites[idxclosest].vx+=step.datas[idx[3]][j]*coeff ;
       boites[idxclosest].vy+=step.datas[idx[4]][j]*coeff ;
       boites[idxclosest].vz+=step.datas[idx[5]][j]*coeff ;
       boites[idxclosest].nb_atomes+=coeff ;

       if (actions["w/kinetic"].set)
         {
    	 vitesse(1)=step.datas[idx[3]][j] ; vitesse(2)=step.datas[idx[4]][j] ; vitesse(3)=step.datas[idx[5]][j] ;
         vitesset=vitesse.t() ;
    	 boites[idxclosest].sigmak=(vitesse.multiply(vitesset))*coeff+boites[idxclosest].sigmak ;
    	 boites[idxclosest].vitk=vitesse*coeff+boites[idxclosest].vitk ;
    	 boites[idxclosest].coeffk+=coeff ;
    	 }
       if (actions["pressureFgrain"].set)
         {
    	 Vector force ;
    	 force(1)=step.datas[step.find_idx(FX)][j] ;
    	 force(2)=step.datas[step.find_idx(FY)][j] ;
    	 force(3)=step.datas[step.find_idx(FZ)][j] ;
    	 boites[idxclosest].pressure=force*coeff+boites[idxclosest].pressure;
         }
       }
     else if (step.Type==TCF)
       {
       f(1)=step.datas[idx[6]][j] ; f(2)=step.datas[idx[7]][j] ; f(3)=step.datas[idx[8]][j] ;
       r(1)=step.datas[idx[3]][j] ; r(2)=step.datas[idx[4]][j] ; r(3)=step.datas[idx[5]][j] ;
       xa=r/(-2.0)+position-boites[idxclosest].x0 ; xb=r/2.+position-boites[idxclosest].x0 ; 
       //boites[idxclosest].x0.disp() ; 
       //xa.disp() ; xb.disp() ; 
       fenetre(coeff,xa, xb, sigmafenetre) ; 
       //if (coeff==0) continue ; 
       boites[idxclosest].sigma=(r.multiply(f))*coeff*(-1)+boites[idxclosest].sigma ;
       boites[idxclosest].nb_contacts+=coeff;
       }
     }
    }
   }      
  }

static bool infogave=false ;
if (!infogave) {cout << "INFO -- Rayon d'un grain : " << setprecision(4) << actions.Radius*1000000 <<"um -- Densité : " << actions.Rhograin << "kg/m3 \n" ;
				cout << "\t\t Lsimu=" << actions.Lsimu*1000 << "mm, Dsimu=" << actions.Dsimu*1000 << "\n\n" ; infogave=true ; }

if (step.Type==TL)
 {
 for (j=0 ; j<nb_boites_tot ; j++)
  {
  //printf("[%f ", boites[j].nb_atomes) ;
	boites[j].nb_atomes*=4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin ;   // TODO : attention : masse d'un grain => on obtient la densité ...
	boites[j].phi=boites[j].nb_atomes/actions.Rhograin ;
	 //boites[j].phi=boites[j].nb_atomes ;
//printf("%f]", boites[j].nb_atomes) ; fflush(stdout) ;
	if (boites[j].nb_atomes>0)
     {
     boites[j].vx=boites[j].vx*(4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin)/(double)boites[j].nb_atomes ;
     boites[j].vy=boites[j].vy*(4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin)/(double)boites[j].nb_atomes ;
     boites[j].vz=boites[j].vz*(4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin)/(double)boites[j].nb_atomes ;
     }
  }
 }
if (actions["w/kinetic"].set && step.Type==TL)
  {
  Vector vitkt ;
  for (j=0 ; j<nb_boites_tot ; j++)
   {
   vitesse(1)=boites[j].vx ; vitesse(2)=boites[j].vx ; vitesse(3)=boites[j].vx ;
   vitesset=vitesse.t() ; vitkt=boites[j].vitk.t() ;
   boites[j].sigmak=-(vitesse.multiply(vitkt)) + boites[j].sigmak ;
   boites[j].sigmak=-(boites[j].vitk.multiply(vitesset)) + boites[j].sigmak ;
   boites[j].sigmak= (vitesse.multiply(vitesset))*boites[j].coeffk + boites[j].sigmak ;
   }
  }

return 1 ;
}

//----------------------- Coarse polydisperse ------------------------
int Coarse::do_coarse_polydisperse(Step &step)
{
int j, k, l ;
double width, height, depth ;
int idx[9], idxlin[2] ;
Vector r, f, xa, xb ;

idx[0]=step.find_idx(POSX) ;
idx[1]=step.find_idx(POSY) ;
idx[2]=step.find_idx(POSZ) ;
if (step.Type==TL)
  {
  idx[3]=step.find_idx(VX) ;
  idx[4]=step.find_idx(VY) ;
  idx[5]=step.find_idx(VZ) ;
  idx[6]=step.find_idx(RAYON) ;
  for (j=0 ; j<7 ; j++)
   {
   if (idx[j]==-1)
   {DISP_Err("L'une des données est manquante pour le coarse polydisperse (x y z vx vy vz r)"); return 0 ; }
   }
  }
else if (step.Type==TCF)
  {
  //DISP_Err ("Coarse polydisperse type TCF not implemented\n") ;
  useCF=true ;
  idx[3]=step.find_idx(CFX) ;
  idx[4]=step.find_idx(CFY) ;
  idx[5]=step.find_idx(CFZ) ;
  idx[6]=step.find_idx(CFFORCEX) ;
  idx[7]=step.find_idx(CFFORCEY) ;
  idx[8]=step.find_idx(CFFORCEZ) ;
  }
else
  {cout << "ERR: ne peut pas faire le coarse grain pour ce type de dump" ; return 0;}

// Parcours de tous les atomes
double coeff, masse ; Vector position ;
const int natomescompt=step.nb_atomes  ;
int bidx[3], idxclosest, ii, jj, kk, bornes[3][2] ; Matrix3x3 sigmatmp ;
Vector vitesse, vitesset ;
int DeltaBoites=1 ;
f=f.t() ;
for (j=0 ; j<natomescompt ; j++)
  {
  //if (actions["periodicity"].set && step.Type==TCF && step.datas[step.find_idx(CFPERIOD)][j]==1) continue ;
  position(1)=step.datas[idx[0]][j] ; position(2)=step.datas[idx[1]][j] ; position(3)=step.datas[idx[2]][j] ;
  // Parcours des boites
  bidx[0]=floor((step.datas[idx[0]][j]-borders[0][0])/(double)((borders[0][1]-borders[0][0])/(double)nb_boites[0])) ;
  bidx[1]=floor((step.datas[idx[1]][j]-borders[1][0])/(double)((borders[1][1]-borders[1][0])/(double)nb_boites[1])) ;
  bidx[2]=floor((step.datas[idx[2]][j]-borders[2][0])/(double)((borders[2][1]-borders[2][0])/(double)nb_boites[2])) ;
  idxclosest=linidx(bidx[0], bidx[1],bidx[2]) ;
  bornes[0][0]=((bidx[0]-DeltaBoites)<0?0:(bidx[0]-DeltaBoites)) ;
  bornes[1][0]=((bidx[1]-DeltaBoites)<0?0:(bidx[1]-DeltaBoites)) ;
  bornes[2][0]=((bidx[2]-DeltaBoites)<0?0:(bidx[2]-DeltaBoites)) ;
  bornes[0][1]=((bidx[0]+DeltaBoites)>=nb_boites[0]?(nb_boites[0]-1):(bidx[0]+DeltaBoites)) ;
  bornes[1][1]=((bidx[1]+DeltaBoites)>=nb_boites[1]?(nb_boites[1]-1):(bidx[1]+DeltaBoites)) ;
  bornes[2][1]=((bidx[2]+DeltaBoites)>=nb_boites[2]?(nb_boites[2]-1):(bidx[2]+DeltaBoites)) ;
  for (ii=bornes[0][0] ; ii<=bornes[0][1] ; ii++)
   {
   for (jj=bornes[1][0] ; jj<=bornes[1][1] ; jj++)
    {
    for (kk=bornes[2][0] ; kk<=bornes[2][1] ; kk++)
     {
     idxclosest=linidx(ii, jj, kk) ;
     if (step.Type==TL)
       {
    		boites[j].nb_atomes*=4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin ;   // TODO : attention : masse d'un grain => on obtient la densité ...
    		boites[j].phi=boites[j].nb_atomes/actions.Rhograin ;
    		if (boites[j].nb_atomes>0)
    	     {
    	     boites[j].vx=boites[j].vx*(4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin)/(double)boites[j].nb_atomes ;
    	     boites[j].vy=boites[j].vy*(4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin)/(double)boites[j].nb_atomes ;
    	     boites[j].vz=boites[j].vz*(4/3.*M_PI*actions.Radius*actions.Radius*actions.Radius*actions.Rhograin)/(double)boites[j].nb_atomes ;
    	     

       xa=position-boites[idxclosest].x0 ;
       if (actions["polydisperse"].set)
    	   {
    	   Fonction::intersect_sphere(coeff, xa, sigmafenetre, step.datas[idx[6]][j]) ;
    	   masse=4/3*M_PI*actions.Rhograin*step.datas[idx[6]][j]*step.datas[idx[6]][j]*step.datas[idx[6]][j] ;
    	   }
       else if (actions["polydisperse2D"].set)
    	   {
    	   Fonction::intersect_cercle(coeff, xa, sigmafenetre, step.datas[idx[6]][j]) ;
    	   masse=M_PI*actions.Rhograin*step.datas[idx[6]][j]*step.datas[idx[6]][j] ;
    	   }
       else DISP_Warn("What the hell am I doing here ?") ;


       boites[idxclosest].nb_atomes+=coeff ;
       boites[idxclosest].mean_radius+=step.datas[idx[6]][j]*coeff ;
       coeff*=masse ;
       boites[idxclosest].phi+=coeff ;
       boites[idxclosest].vx+=step.datas[idx[3]][j]*coeff ;
       boites[idxclosest].vy+=step.datas[idx[4]][j]*coeff ;
       boites[idxclosest].vz+=step.datas[idx[5]][j]*coeff ;
       }

     else if (step.Type==TCF)
       //DISP_Err ("Coarse polydisperse type TCF not implemented\n") ;
       {
       if (actions["polydisperse"].set)
    	  {
    	  DISP_Err ("TCF Polydisperse 3D not implemented (mais pourrait fonctionner sans grand changement cela dit ...)\n") ;
    	  }
       else if (actions["polydisperse2D"].set)
    	  {
    	  Fonction::intersect_cercle(coeff, xa, sigmafenetre, step.datas[idx[6]][j]) ;
    	  masse=M_PI*actions.Rhograin*step.datas[idx[6]][j]*step.datas[idx[6]][j] ;
    	  }
       else DISP_Warn("What the hell am I doing here (TCF) ?") ;
       
       f(1)=step.datas[idx[6]][j] ; f(2)=step.datas[idx[7]][j] ; f(3)=step.datas[idx[8]][j] ;
       r(1)=step.datas[idx[3]][j] ; r(2)=step.datas[idx[4]][j] ; r(3)=step.datas[idx[5]][j] ;
       xa=r/(-2.0)+position-boites[idxclosest].x0 ; xb=r/2.+position-boites[idxclosest].x0 ;
       //boites[idxclosest].x0.disp() ;
       //xa.disp() ; xb.disp() ;
       fenetre(coeff,xa, xb, sigmafenetre) ;
       //if (coeff==0) continue ;
       boites[idxclosest].sigma=(r.multiply(f))*coeff*(-1)+boites[idxclosest].sigma ;
       boites[idxclosest].nb_contacts+=coeff;

       }
     }
    }
   }
  }

static bool infogave=false ;
if (!infogave) {cout << "INFO -- Rayon d'un grain : " << setprecision(4) << actions.Radius*1000000 <<"um -- Densité : " << actions.Rhograin << "kg/m3 \n" ;
				cout << "\t\t Lsimu=" << actions.Lsimu*1000 << "mm, Dsimu=" << actions.Dsimu*1000 << "\n\n" ; infogave=true ; }

if (step.Type==TL)
 {
 for (j=0 ; j<nb_boites_tot ; j++)
  {
	boites[j].phi=boites[j].phi/actions.Rhograin ;
	if (boites[j].nb_atomes>0)
     {
     boites[j].vx=boites[j].vx/(boites[j].phi*actions.Rhograin) ;
     boites[j].vy=boites[j].vy/(boites[j].phi*actions.Rhograin) ;
     boites[j].vz=boites[j].vz/(boites[j].phi*actions.Rhograin) ;
     boites[j].mean_radius=boites[j].mean_radius/boites[j].nb_atomes ;
     }
  }
 }

return 1 ;
}
*/



//--------------------------------------------------------------------------
int Coarse::write_asVTK(ofstream &out)
{
int i,j,k ;
out << "# vtk DataFile Version 2.0\n" << "This is a coarse graining file\nASCII\n" << "DATASET STRUCTURED_GRID\n" ; 
out << "DIMENSIONS " <<nb_boites[0] << " " << nb_boites[1] << " " << nb_boites[2] << "\n" ; 
out << "POINTS " << nb_boites_tot << " double\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].x0(1) << " " << boites[linidx(i,j,k)].x0(2) << " " << boites[linidx(i,j,k)].x0(3) << "\n" ; 
      }
    }
  }
out << "POINT_DATA " << nb_boites_tot << "\n"; 
out << "SCALARS phi double 1\nLOOKUP_TABLE default\n" ;
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].phi << "\n" ;
      }
    }
  }

out << "SCALARS nb_atomes double 1\nLOOKUP_TABLE default\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].nb_atomes << "\n" ; 
      }
    }
  }  
  
out << "SCALARS mean_radius double 1\nLOOKUP_TABLE default\n" ;
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].mean_radius << "\n" ;
      }
    }
  }  

out << "VECTORS mean_speed double\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].vx << " " << boites[linidx(i,j,k)].vy << " " << boites[linidx(i,j,k)].vz << "\n" ; 
      }
    }
  }

out << "TENSORS sigma double\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].sigma(1,1) << " " << boites[linidx(i,j,k)].sigma(1,2) << " " << boites[linidx(i,j,k)].sigma(1,3) << " " ; 
      out << boites[linidx(i,j,k)].sigma(2,1) << " " << boites[linidx(i,j,k)].sigma(2,2) << " " << boites[linidx(i,j,k)].sigma(2,3) << " " ; 
      out << boites[linidx(i,j,k)].sigma(3,1) << " " << boites[linidx(i,j,k)].sigma(3,2) << " " << boites[linidx(i,j,k)].sigma(3,3) << "\n" ; 
      }
    }
  }

out << "TENSORS sigmak double\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].sigmak(1,1) << " " << boites[linidx(i,j,k)].sigmak(1,2) << " " << boites[linidx(i,j,k)].sigmak(1,3) << " " ; 
      out << boites[linidx(i,j,k)].sigmak(2,1) << " " << boites[linidx(i,j,k)].sigmak(2,2) << " " << boites[linidx(i,j,k)].sigmak(2,3) << " " ; 
      out << boites[linidx(i,j,k)].sigmak(3,1) << " " << boites[linidx(i,j,k)].sigmak(3,2) << " " << boites[linidx(i,j,k)].sigmak(3,3) << "\n" ; 
      }
    }
  }  
  
out << "TENSORS sigmatot double\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].sigmatot(1,1) << " " << boites[linidx(i,j,k)].sigmatot(1,2) << " " << boites[linidx(i,j,k)].sigmatot(1,3) << " " ; 
      out << boites[linidx(i,j,k)].sigmatot(2,1) << " " << boites[linidx(i,j,k)].sigmatot(2,2) << " " << boites[linidx(i,j,k)].sigmatot(2,3) << " " ; 
      out << boites[linidx(i,j,k)].sigmatot(3,1) << " " << boites[linidx(i,j,k)].sigmatot(3,2) << " " << boites[linidx(i,j,k)].sigmatot(3,3) << "\n" ; 
      }
    }
  } 

out << "SCALARS nbliens double 1\nLOOKUP_TABLE default\n" ; 
for (k=0 ; k<nb_boites[2]; k++)
  {
  for (j=0 ; j<nb_boites[1]; j++)
    {
    for (i=0 ; i<nb_boites[0] ; i++)
      {
      out << boites[linidx(i,j,k)].nb_contacts << "\n" ; 
      }
    }
  }

return 1 ;
}

//--------------------------------------------------------------------------------
int Coarse::write_asMatlab (ofstream &out_vx, ofstream &out_phi)
{
int j ;
DISP_Warn("La gestion de la sortie Matlab de coarse-graining est très primitive. Seul vx est extrait") ;
for (j=0 ; j<nb_boites_tot ; j++)
 {
 out_vx << setprecision (6) << boites[j].x0(1) << " " << boites[j].x0(2) << " " << boites[j].x0(3) << " " << boites[j].vx << "\n" ;
 out_phi << setprecision (6) << boites[j].x0(1) << " " << boites[j].x0(2) << " " << boites[j].x0(3) << " " << boites[j].phi << "\n" ;
 }
return 1 ;
}

int Coarse::write_asMatlabTCF2D (ofstream &out_sigma)
{
int j ;
DISP_Warn("La gestion de la sortie Matlab de coarse-graining est très primitive. Seul sigma est extrait") ;
for (j=0 ; j<nb_boites_tot ; j++) 
 {
 out_sigma << setprecision (6) << boites[j].x0(1) << " " << boites[j].x0(2) << " " << boites[j].x0(3) << " " << boites[j].sigma[0] << " "  ;
 out_sigma << setprecision (6) << boites[j].sigma[1] << " " << boites[j].sigma[3] << " " << boites[j].sigma[4] << "\n" ;
 }
return 1 ;
}

//==========================================================================
//==========================================================================
Boites operator+ (Boites b1, Boites b2)
{
  Boites temp ; 
  
 if (b1==b2)
   temp=b1 ; 
 else
 {cout << "ERR : tentative d'ajout de boîtes non compatibles\n" ; return temp ; }

 temp.nb_atomes=b1.nb_atomes+b2.nb_atomes ; 
 temp.nb_contacts=b1.nb_contacts+b2.nb_contacts ; 
 temp.vx=b1.vx+b2.vx ; 
 temp.vy=b1.vy+b2.vy ; 
 temp.vz=b1.vz+b2.vz ; 
 temp.sigma=b1.sigma+b2.sigma ; 
 temp.sigmak=b1.sigmak+b2.sigmak ;
 temp.sigmatot=b1.sigmatot+b2.sigmatot ;
 temp.phi=b1.phi+b2.phi ;
 temp.mean_radius=b1.mean_radius+b2.mean_radius ;
 return temp ; 
}

//--------------------------------------------------------------------------
void Boites::operator= (Boites b)
{
  x0=b.x0 ; 
  nb_atomes=b.nb_atomes ; 
  vx=b.vx ; vy=b.vy ; vz=b.vz ; 
  phi=b.phi ; 
  mean_radius=b.mean_radius ;
  //volume=b.volume ; 
  sigma=b.sigma ; nb_contacts=b.nb_contacts ; 
  sigmak=b.sigmak ;
  sigmatot=b.sigmatot ;
}

//----------------------------------------------------------------------
bool operator== (Boites b1, Boites b2)
{
 if (b1.x0(1)==b2.x0(1) && b1.x0(2)==b2.x0(2) && b1.x0(3)==b2.x0(3))
   return true ; 
 else
   return false ; 
}







/*=========================================================*/
int CoarseDump::do_coarse_basic (Dump &dump, string chemin)   // Coarse basic : seulement du LDump, avec boîte créneau de base, toujours moyennée en temps
{
long int debut, fin, step ;
int  i,j, idx[6] ; Coarse coarse_null ;
int bidx[3], idxclosest ;
long int loop[3] ;

actions.copyarg("coarse-graining-basic", "coarse-graining") ;
dump.loopdat(loop) ;

cout << "\nCoarseDump::do_coarse_basic          " ;
actions.total=loop[2]-loop[0] ; actions.valeur=i ;actions.disp_progress() ;
coarse.resize(1, coarse_null) ;

i=loop[0] ;
dump.check_timestep(loop[0]) ;
coarse[0].coarse(dump.steps[i]) ;  // First corse, on initialise les boîtes.
idx[0]=dump.steps[i].find_idx(POSX) ; idx[1]=dump.steps[i].find_idx(POSY) ; idx[2]=dump.steps[i].find_idx(POSZ) ;
idx[3]=dump.steps[i].find_idx(VX) ; idx[4]=dump.steps[i].find_idx(VY) ; idx[5]=dump.steps[i].find_idx(VZ) ;

for (i=loop[0] ; i<loop[2] ; i+=loop[1])
    {
    actions.valeur=i ;
    dump.check_timestep(i) ;
    for (j=0 ; j<dump.steps[i].nb_atomes ; j++)
     {
     bidx[0]=floor((dump.steps[i].datas[idx[0]][j]-coarse[0].borders[0][0])/(double)((coarse[0].borders[0][1]-coarse[0].borders[0][0])/(double)coarse[0].nb_boites[0])) ;
     bidx[1]=floor((dump.steps[i].datas[idx[1]][j]-coarse[0].borders[1][0])/(double)((coarse[0].borders[1][1]-coarse[0].borders[1][0])/(double)coarse[0].nb_boites[1])) ;
     bidx[2]=floor((dump.steps[i].datas[idx[2]][j]-coarse[0].borders[2][0])/(double)((coarse[0].borders[2][1]-coarse[0].borders[2][0])/(double)coarse[0].nb_boites[2])) ;
     bidx[0]=bidx[0]<0?0:bidx[0] ; bidx[1]=bidx[1]<0?0:bidx[1] ; bidx[2]=bidx[2]<0?0:bidx[2] ;
     bidx[0]=bidx[0]>=coarse[0].nb_boites[0]?coarse[0].nb_boites[0]-1:bidx[0] ;
     bidx[1]=bidx[1]>=coarse[0].nb_boites[1]?coarse[0].nb_boites[1]-1:bidx[1] ;
     bidx[2]=bidx[2]>=coarse[0].nb_boites[2]?coarse[0].nb_boites[2]-1:bidx[2] ;

     idxclosest=coarse[0].linidx(bidx[0], bidx[1],bidx[2]) ;

     coarse[0].boites[idxclosest].vx+=dump.steps[i].datas[idx[3]][j] ;
     coarse[0].boites[idxclosest].vy+=dump.steps[i].datas[idx[4]][j] ;
     coarse[0].boites[idxclosest].vz+=dump.steps[i].datas[idx[5]][j] ;
     coarse[0].boites[idxclosest].nb_atomes+=1 ;
     }
    }
for (i=0 ; i<coarse[0].nb_boites[0]*coarse[0].nb_boites[1]*coarse[0].nb_boites[2] ; i++)
{
	coarse[0].boites[i].vx/=coarse[0].boites[i].nb_atomes ;
	coarse[0].boites[i].vy/=coarse[0].boites[i].nb_atomes ;
	coarse[0].boites[i].vz/=coarse[0].boites[i].nb_atomes ;
	coarse[0].boites[i].phi=coarse[0].boites[i].nb_atomes ;
}

ofstream out ;
stringstream chemin2 ;

// Write as VTK
chemin2.str("") ;
chemin2 << chemin << "-BasicCoarse.vtk" ;
chemin2 << "Basic-coarse.vtk" ;
out.open(chemin2.str().c_str(), ios::out) ;
coarse[0].write_asVTK(out) ;
out.close() ;

// Write as matlab
chemin2.str("") ;
chemin2 << chemin << "-BasicCoarse.txt" ;
out.open(chemin2.str().c_str(), ios::out) ;
for (i=0 ; i<coarse[0].nb_boites[0]*coarse[0].nb_boites[1]*coarse[0].nb_boites[2] ; i++)
{
	out << coarse[0].boites[i].x0(1) << " " << coarse[0].boites[i].x0(2) << " " << coarse[0].boites[i].x0(3) << " " ;
	out << coarse[0].boites[i].vx << " " << coarse[0].boites[i].vy << " " << coarse[0].boites[i].vz << " " << coarse[0].boites[i].phi << "\n"  ;
}
out.close() ;


return 1 ;
}




//===============================================
// Réécriuture des fonctions de Dump pour faire l'encapsulation pour le Writing

int CoarseDump::open (string chemin) {
int i ; Step null_step ;
if (chemin.length() >0) DISP_Warn("Chemin devrait être vide ...") ;
// Mise en place du vecteur de step

for (i=0 ; i<nb_coarse ; i++) 
{
  steps.push_back(null_step) ; 
  steps[i].Type=TCOARSE ; 
}
nbsteps=nb_coarse;
printf("%d ", nbsteps) ; 
return 1; 
}

int CoarseDump::check_timestep (long int timestep) 
{
int i ; 
if (inscrit==timestep) return 1 ;
if (inscrit>=0) // il faut libérer la mémoire
  {
  inscrit=free_timestep(inscrit) ;
  } 

steps[timestep].idx_col.push_back(POSX) ; steps[timestep].idx_col.push_back(POSY) ; steps[timestep].idx_col.push_back(POSZ) ;
steps[timestep].idx_col.push_back(VX) ; steps[timestep].idx_col.push_back(VY) ; steps[timestep].idx_col.push_back(VZ) ;
steps[timestep].idx_col.push_back(COARPHI); steps[timestep].idx_col.push_back(COARATM); steps[timestep].idx_col.push_back(COARCONTACTS); steps[timestep].idx_col.push_back(COARRAD );
steps[timestep].idx_col.push_back(SIGMAXX); steps[timestep].idx_col.push_back(SIGMAXY); steps[timestep].idx_col.push_back(SIGMAXZ);
steps[timestep].idx_col.push_back(SIGMAYX); steps[timestep].idx_col.push_back(SIGMAYY); steps[timestep].idx_col.push_back(SIGMAYZ);
steps[timestep].idx_col.push_back(SIGMAZX); steps[timestep].idx_col.push_back(SIGMAZY); steps[timestep].idx_col.push_back(SIGMAZZ);

steps[timestep].idx_col.push_back(COARSIGKXX); steps[timestep].idx_col.push_back(COARSIGKXY); steps[timestep].idx_col.push_back(COARSIGKXZ);
steps[timestep].idx_col.push_back(COARSIGKYX); steps[timestep].idx_col.push_back(COARSIGKYY); steps[timestep].idx_col.push_back(COARSIGKYZ);
steps[timestep].idx_col.push_back(COARSIGKZX); steps[timestep].idx_col.push_back(COARSIGKZY); steps[timestep].idx_col.push_back(COARSIGKZZ);

steps[timestep].idx_col.push_back(COARTOTXX ); steps[timestep].idx_col.push_back(COARTOTXY ); steps[timestep].idx_col.push_back(COARTOTXZ );
steps[timestep].idx_col.push_back(COARTOTYX ); steps[timestep].idx_col.push_back(COARTOTYY ); steps[timestep].idx_col.push_back(COARTOTYZ );
steps[timestep].idx_col.push_back(COARTOTZX ); steps[timestep].idx_col.push_back(COARTOTZY ); steps[timestep].idx_col.push_back(COARTOTZZ );

steps[timestep].nb_atomes=coarse[timestep].nb_boites_tot ; 
steps[timestep].nb_idx=steps[timestep].idx_col.size() ; 
steps[timestep].datas.resize(steps[timestep].idx_col.size()) ; 

IterStructGrid it (coarse[timestep].nb_boites) ; 
for (i=0 ; i<steps[timestep].nb_idx ; i++)
  steps[timestep].datas[i].resize(steps[timestep].nb_atomes) ; 

for (it=0 ; (it) ; it++)
{
  steps[timestep].datas[0][it.idx()]=coarse[timestep].boites[(int)it].x0(1) ; 
  steps[timestep].datas[1][it.idx()]=coarse[timestep].boites[(int)it].x0(2) ;
  steps[timestep].datas[2][it.idx()]=coarse[timestep].boites[(int)it].x0(3) ;
  steps[timestep].datas[3][it.idx()]=coarse[timestep].boites[(int)it].vx ;
  steps[timestep].datas[4][it.idx()]=coarse[timestep].boites[(int)it].vy ;
  steps[timestep].datas[5][it.idx()]=coarse[timestep].boites[(int)it].vz ;
  steps[timestep].datas[6][it.idx()]=coarse[timestep].boites[(int)it].phi ;
  steps[timestep].datas[7][it.idx()]=coarse[timestep].boites[(int)it].nb_atomes ;
  steps[timestep].datas[8][it.idx()]=coarse[timestep].boites[(int)it].nb_contacts ;
  steps[timestep].datas[9][it.idx()]=coarse[timestep].boites[(int)it].mean_radius ;
  
  steps[timestep].datas[10][it.idx()]=coarse[timestep].boites[(int)it].sigma(1,1) ;
  steps[timestep].datas[11][it.idx()]=coarse[timestep].boites[(int)it].sigma(1,2) ;
  steps[timestep].datas[12][it.idx()]=coarse[timestep].boites[(int)it].sigma(1,3) ;
  steps[timestep].datas[13][it.idx()]=coarse[timestep].boites[(int)it].sigma(2,1) ;
  steps[timestep].datas[14][it.idx()]=coarse[timestep].boites[(int)it].sigma(2,2) ;
  steps[timestep].datas[15][it.idx()]=coarse[timestep].boites[(int)it].sigma(2,3) ;
  steps[timestep].datas[16][it.idx()]=coarse[timestep].boites[(int)it].sigma(3,1) ;
  steps[timestep].datas[17][it.idx()]=coarse[timestep].boites[(int)it].sigma(3,2) ;
  steps[timestep].datas[18][it.idx()]=coarse[timestep].boites[(int)it].sigma(3,3) ;
  
  steps[timestep].datas[19][it.idx()]=coarse[timestep].boites[(int)it].sigmak(1,1) ;
  steps[timestep].datas[20][it.idx()]=coarse[timestep].boites[(int)it].sigmak(1,2) ;
  steps[timestep].datas[21][it.idx()]=coarse[timestep].boites[(int)it].sigmak(1,3) ;
  steps[timestep].datas[22][it.idx()]=coarse[timestep].boites[(int)it].sigmak(2,1) ;
  steps[timestep].datas[23][it.idx()]=coarse[timestep].boites[(int)it].sigmak(2,2) ;
  steps[timestep].datas[24][it.idx()]=coarse[timestep].boites[(int)it].sigmak(2,3) ;
  steps[timestep].datas[25][it.idx()]=coarse[timestep].boites[(int)it].sigmak(3,1) ;
  steps[timestep].datas[26][it.idx()]=coarse[timestep].boites[(int)it].sigmak(3,2) ;
  steps[timestep].datas[27][it.idx()]=coarse[timestep].boites[(int)it].sigmak(3,3) ;
  
  steps[timestep].datas[28][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(1,1) ;
  steps[timestep].datas[29][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(1,2) ;
  steps[timestep].datas[30][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(1,3) ;
  steps[timestep].datas[31][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(2,1) ;
  steps[timestep].datas[32][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(2,2) ;
  steps[timestep].datas[33][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(2,3) ;
  steps[timestep].datas[34][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(3,1) ;
  steps[timestep].datas[35][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(3,2) ;
  steps[timestep].datas[36][it.idx()]=coarse[timestep].boites[(int)it].sigmatot(3,3) ; 
}

//--------- Fin des filtres --------
inscrit=timestep ;
return 2 ; 
}


int CoarseDump::free_timestep (long int inscrit) 
{
int i ; 

for (i=0 ; i<steps[inscrit].nb_idx ; i++)
     {steps[inscrit].datas[i].clear() ; }
  steps[inscrit].datas.clear() ; 
  steps[inscrit].idx_col.clear() ;
  steps[inscrit].nb_idx=0 ; 
  inscrit=-1 ; 
return inscrit ; 
  
}












