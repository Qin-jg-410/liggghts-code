#include "Headers/Step.h"

// =====================================================
// Fonctions de la classe Step, type LStep================
// =====================================================
// =====================================================
// Fonctions orientées LStep ===========================
//======================================================
void Step::Ldisp(void)
{
  cout << "Timestep : " << timestep << "\n" ;
  cout << "Nb atomes : " << nb_atomes << "\n" ;
  cout << "Box : " << box[0][0] << " "<< box[0][1] << " "<< box[1][0] << " "<< box[1][1] << " "<< box[2][0] << " "<< box[2][1] << "\n" ;
  cout << "Nb idx : " << nb_idx << "\n\n" ;
}
//-----------------------------
void Step::del_atm (long int atm)
{
 int i ;
 for (i=0 ; i<nb_idx ; i++)
 {if (idx_col[i]==POINTX || idx_col[i]==POINTY || idx_col[i]==POINTZ) continue ;
  datas[i].erase(datas[i].begin()+atm) ;}
}
//-----------------------------
void Step::swap_atm (long int atm1, long int atm2)
{
 int i ; double tmp ;
 for (i=0 ; i<nb_idx ; i++)
 {if (idx_col[i]==POINTX || idx_col[i]==POINTY || idx_col[i]==POINTZ) continue ;
  tmp=datas[i][atm1] ; datas[i][atm1]=datas[i][atm2] ; datas[i][atm2]=tmp ; }
}
//-----------------------------
void Step::crush_atm (long int atm1, long int atm2)
{
 int i ; double tmp ;
 for (i=0 ; i<nb_idx ; i++)
 {datas[i][atm1]=datas[i][atm2] ;}
}
//----------------------------
void Step::del_end_atms (long int nb)
{
 int i ;
 for (i=0 ; i<nb_idx ; i++)
 {if (idx_col[i]==POINTX || idx_col[i]==POINTY || idx_col[i]==POINTZ) continue ;
  datas[i].erase(datas[i].end()-nb, datas[i].end()-1) ;}
}
//-----------------------------
void Step::copy_atm_end (long int nb)
{
 int i ;
 for (i=0 ; i<nb_idx ; i++)
 {if (idx_col[i]==POINTX || idx_col[i]==POINTY || idx_col[i]==POINTZ) continue ;
  datas[i].push_back(datas[i][nb]) ; }
}
//-----------------------------
void Step::Lwrite_asVTK(ofstream &out)
{
int i , idx[3];
out << "# vtk DataFile Version 2.0\n" ;
out << "Generated by AVFF\nASCII\nDATASET POLYDATA\n" ;
out << "POINTS " << nb_atomes << " double\n" ;

idx[0]=find_idx(POSX) ;
idx[1]=find_idx(POSY) ;
idx[2]=find_idx(POSZ) ;

for (i=0 ; i<nb_atomes ; i++)
{
 out << datas[idx[0]][i] << " " << datas[idx[1]][i] << " " << datas[idx[2]][i] << "\n" ;
}

out << "VERTICES " <<nb_atomes << " "<< nb_atomes*2 << "\n" ;

for (i=0 ; i<nb_atomes ; i++)
  {out << "1 " << i <<"\n" ;}

out << "POINT_DATA " << nb_atomes << "\n" ;
out << "SCALARS atom_type int 1\n" ;
out << "LOOKUP_TABLE default\n" ;
idx[0]=find_idx(TYPE) ;
if (idx[0]==-1)
  {
  for (i=0 ; i<nb_atomes ; i++) out << "1 " ;
  }
else
  {
  for (i=0 ; i<nb_atomes ; i++) {out << datas[idx[0]][i] << " " ;}
  }

if (actions["w/speed"].set)
 {
 idx[0]=find_idx(VX) ; idx[1]=find_idx(VY) ; idx[2]=find_idx(VZ) ;

 out << "VECTORS vitesse double\n" ;
 for (i=0 ; i<nb_atomes ; i++)
   {
   out <<datas[idx[0]][i] << " " << datas[idx[1]][i] << " " <<datas[idx[2]][i] << "\n" ;
   }
 }


if (actions["w/force"].set)
 {
 idx[0]=find_idx(FX) ; idx[1]=find_idx(FY) ; idx[2]=find_idx(FZ) ;

 out << "VECTORS force double\n" ;
 for (i=0 ; i<nb_atomes ; i++)
   {
   out <<datas[idx[0]][i] << " " << datas[idx[1]][i] << " " <<datas[idx[2]][i] << "\n" ;
   }
 }

if (actions["w/id"].set)
 {
 idx[0]=find_idx(ID) ;
 out << "SCALARS atom_id int 1\n" ;
 out << "LOOKUP_TABLE default\n" ;
 for (i=0 ; i<nb_atomes-1 ; i++)
   {
   out << datas[idx[0]][i] << " " ;
   }
 out << datas[idx[0]][nb_atomes-1] <<"\n" ;
 }

if (actions["w/rayon"].set)
 {
 idx[0]=find_idx(RAYON) ;
 out << "SCALARS atom_rayon double 1\n" ;
 out << "LOOKUP_TABLE default\n" ;
 for (i=0 ; i<nb_atomes-1 ; i++)
   {
   out << datas[idx[0]][i] << " " ;
   }
 out << datas[idx[0]][nb_atomes-1] <<"\n" ;
 }

if (actions["w/masse"].set)
 {
 idx[0]=find_idx(MASSE) ;
 out << "SCALARS atom_masse double 1\n" ;
 out << "LOOKUP_TABLE default\n" ;
 for (i=0 ; i<nb_atomes-1 ; i++)
   {
   out << datas[idx[0]][i] << " " ;
   }
 out << datas[idx[0]][nb_atomes-1] <<"\n" ;
 }

}
//--------------------------------------------------------------------------
void Step::Lwrite_asRESTART (ofstream &out)
{
int i ; int idx[6] ; int maxtype=0 ;
// Nb : ne fonctionne que pur les grains de type liggghts granular !!
DISP_Info("Ceci ne fonctionne que pour les grains de type granular\n") ;
cout << "Ecriture du timestep " << timestep << ".\n";

out << "Donnees atomiques generees par POSTPROCESSING. Permet une insertion d'atomes via la commande liggghts read_data.\n\n" ;
out << "#========================================================\n" ;
out << "# Header\n" ;
out << "#========================================================\n" ;
out << "   " << nb_atomes << " atoms\n" ;
out << "   1 atom types\n" ;
out << box[0][0] << " " << box[0][1] << " xlo xhi\n" ;
out << box[1][0] << " " << box[1][1] << " ylo yhi\n" ;
out << box[2][0] << " " << box[2][1] << " zlo zhi\n\n" ;

out <<"#======================================================\n" ;
out <<"# Atomes\n#======================================================\n\n" ;
out << "Atoms\n\n" ;

idx[0]=find_idx(ID) ;
idx[1]=find_idx(TYPE) ;
idx[2]=find_idx(POSX) ; idx[3]=find_idx(POSY) ; idx[4]=find_idx(POSZ) ;
idx[5]=find_idx(RAYON) ;
DISP_Info("La densité des atomes est fixée à 2500 !\n") ;

for (i=0 ; i<nb_atomes ; i++)
  {
  out << i+1 << " " << datas[idx[1]][i] << " " ;
  //out << datas[idx[0]][i] << " " << datas[idx[1]][i] <<" ";
  out << datas[idx[5]][i]*2 << " 2500 " ;
  out << datas[idx[2]][i] << " " << datas[idx[3]][i] << " " << datas[idx[4]][i] << "\n" ;
  if (datas[idx[1]][i]>maxtype) maxtype=datas[idx[1]][i] ;
  }
if (maxtype>1)
  DISP_Warn("Attention : il y a plus d'1 type d'atome, une erreur surviendra sans doute dans liggghts !") ;

out.close() ;
}
//------------------------------------------------------
int Step::Lmean_forces(double fr[])
{
int idx[3], i ;
fr[0]=fr[1]=fr[2]=0.0 ;

idx[0]=find_idx(FORCEWALLX) ; idx[1]=find_idx(FORCEWALLY) ; idx[2]=find_idx(FORCEWALLZ) ;
if (idx[0]==-1||idx[1]==-1||idx[2]==-1)
   {DISP_Err("Les valeurs FORCEWALLX/FORCEWALLY/FORCEWALLZ sont necessaires avec --w/forcetot et un Ldump") ; return 1 ; }

for (i=0 ; i<nb_atomes ; i++)
   {
   fr[0]+=datas[idx[0]][i] ;
   fr[1]+=datas[idx[1]][i] ;
   fr[2]+=datas[idx[2]][i] ;
   }
return 0;
}
//-----------------------------------
int Step::wall_force(ofstream & out, double ** meanforces, int * meangrains)
{
double dtheta, angle, anglecentre, posx, posz, Fn ; int boites ;
int i, j, idx[6], fen ;
double **forces, factor, sigma ; int *grains ;
static bool info=true ;

// Initialisation des boites
boites=actions["wallforce-by-angle"]["nbbox_theta"] ;
dtheta=2*M_PI/(double)boites ;
posx=actions["wallforce-by-angle"]["xcyl"] ;
posz=actions["wallforce-by-angle"]["zcyl"] ;
// Initialisation des tableaux
forces=(double **)malloc(boites*sizeof(double *)) ;
grains=(int *)malloc(boites*sizeof(int)) ;
for (i=0 ; i<boites ; i++)
   {forces[i]=(double *)malloc(7*sizeof(double)) ; forces[i][0]=forces[i][1]=forces[i][2]=0 ; grains[i]=0 ;
    forces[i][3]=0 ; forces[i][4]=forces[i][5]=forces[i][6]=0 ;}

// Initialisation des index
idx[0]=find_idx(FORCEWALLX ) ; idx[1]=find_idx(FORCEWALLY) ; idx[2]=find_idx(FORCEWALLZ) ;
idx[3]=find_idx(POSX) ; idx[4]=find_idx(POSY) ; idx[5]=find_idx(POSZ) ;
if (idx[0]==-1||idx[1]==-1||idx[2]==-1||idx[3]==-1||idx[4]==-1||idx[5]==-1)
   {DISP_Err("Les valeurs FORCEWALLX/FORCEWALLY/FORCEWALLZ sont necessaires avec --w/forcetot et un Ldump") ; return 1 ; }

if (actions["wallforce-by-angle"]["sigma"]==0) {fen=1; if (info) {DISP_Info("Utilisation d'une fenêtre créneau") ; info=false ; } } // Fenêtre créneau
else {sigma=actions["wallforce-by-angle"]["sigma"]/180*M_PI ; fen=2; if(info) {DISP_Info ("Utilisation d'une fenêtre gaussienne") ; info=false ; } } // Fenêtre gaussienne


// Parcours des atomes, ajout des forces aux angles adaptés
for (i=0 ; i<nb_atomes ; i++)
	{
	if (datas[idx[0]][i]!=0 || datas[idx[2]][i]!=0 || datas[idx[1]][i]!=0)
	 {
	 angle=Calcul::arctan(datas[idx[3]][i]-posx, datas[idx[5]][i]-posz) ;
	 angle=Calcul::angle_0_2pi(angle) ;

	 for (j=0 ; j<boites ; j++)
	   {
	   anglecentre=angle-(j*dtheta+dtheta/2) ;
	   if (anglecentre>M_PI) anglecentre=anglecentre-2*M_PI ;
	   if (anglecentre<-M_PI) anglecentre=anglecentre+2*M_PI ;
	   if (fen==1) Fonction::creneau1D (factor, anglecentre, dtheta) ;
	   else     Fonction::gaussienne1D (factor, anglecentre, sigma ) ;

	   factor*=dtheta ;
	   // Force totale
	   forces[j][0]+=(factor*datas[idx[0]][i]) ; forces[j][1]+=(factor*datas[idx[1]][i]) ; forces[j][2]+=(factor*datas[idx[2]][i]) ;

	   // Force normale
	   Fn=datas[idx[0]][i]*cos(angle)+datas[idx[2]][i]*sin(angle) ;
	   forces[j][3]+=factor*Fn ;

	   // Force tangentielle
	   forces[j][4]+=factor*(datas[idx[0]][i]-Fn*cos(angle)) ;
	   forces[j][5]+=factor*(datas[idx[1]][i]) ;
	   forces[j][6]+=factor*(datas[idx[2]][i]-Fn*sin(angle)) ;

	   grains[j]+=factor ;
	   }

	 }
	}

// Ecriture des données et éventuellement ajout pour moyennage
for (i=0 ; i<boites ; i++)
   {
   if (actions["mean"].set)
      { for (j=0 ; j<7 ; j++) meanforces[i][j]+=forces[i][j] ;
        meangrains[i]+=grains[i] ; }
   out << (i*dtheta+dtheta/2) << " " << grains[i] << " "<< forces[i][0] << " " << forces[i][1] << " " << forces[i][2] << " " << forces[i][3] << " ";
   out << forces[i][4] << " " << forces[i][5] << " " << forces[i][6] << " " ;
   }

// Cleanning
for (i=0 ; i<boites ; i++)
   {free(forces[i]) ; }
free(forces) ;
free(grains) ;

return 0 ;
}

//------------------------------------------------------
int Step::Latm_rotate(Matrix3x3 & rot, int id)
{
int idx[3] ;
Vector pt1 ;

idx[0]=find_idx(POSX) ; idx[1]=find_idx(POSY) ; idx[2]=find_idx(POSZ) ;
if (idx[0]!=-1 && idx[1]!=-1 && idx[2]!=-1)
  {
  pt1=Convert::toVect(datas[idx[0]][id], datas[idx[1]][id], datas[idx[2]][id]) ;
  pt1=Geometrie::rotation(pt1, rot) ;
  datas[idx[0]][id]=pt1(1) ; datas[idx[1]][id]=pt1(2) ; datas[idx[2]][id]=pt1(3) ;
  }

idx[0]=find_idx(VX) ; idx[1]=find_idx(VY) ; idx[2]=find_idx(VZ) ;
if (idx[0]!=-1 && idx[1]!=-1 && idx[2]!=-1)
   {
   pt1=Convert::toVect(datas[idx[0]][id], datas[idx[1]][id], datas[idx[2]][id]) ;
   pt1=Geometrie::rotation(pt1, rot) ;
   datas[idx[0]][id]=pt1(1) ; datas[idx[1]][id]=pt1(2) ; datas[idx[2]][id]=pt1(3) ;
   }

idx[0]=find_idx(FX) ; idx[1]=find_idx(FY) ; idx[2]=find_idx(FZ) ;
if (idx[0]!=-1 && idx[1]!=-1 && idx[2]!=-1)
  {
  pt1=Convert::toVect(datas[idx[0]][id], datas[idx[1]][id], datas[idx[2]][id]) ;
  pt1=Geometrie::rotation(pt1, rot) ;
  datas[idx[0]][id]=pt1(1) ; datas[idx[1]][id]=pt1(2) ; datas[idx[2]][id]=pt1(3) ;
  }

return 1 ;
}


